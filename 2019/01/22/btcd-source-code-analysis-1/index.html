<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-kelp.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-kelp.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-kelp.png">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":{"disqus":{"text":"Load Disqus","order":-1}}},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我们从“新区块的生成“开始我们的btcd源码之旅。">
<meta property="og:type" content="article">
<meta property="og:title" content="btcd源码解析——从“新区块的生成”开始 (1)">
<meta property="og:url" content="http://example.com/2019/01/22/btcd-source-code-analysis-1/index.html">
<meta property="og:site_name" content="Seafooler&#39;s Blog">
<meta property="og:description" content="我们从“新区块的生成“开始我们的btcd源码之旅。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-01-21T16:00:00.000Z">
<meta property="article:modified_time" content="2022-01-06T04:07:06.758Z">
<meta property="article:author" content="Seafooler">
<meta property="article:tag" content="Blockchain">
<meta property="article:tag" content="Bitcoin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2019/01/22/btcd-source-code-analysis-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>btcd源码解析——从“新区块的生成”开始 (1) | Seafooler's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Seafooler's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/01/22/btcd-source-code-analysis-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seafooler">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seafooler's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          btcd源码解析——从“新区块的生成”开始 (1)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-22 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-22T00:00:00+08:00">2019-01-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Code-analysis/" itemprop="url" rel="index"><span itemprop="name">Code analysis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>我们从“新区块的生成“开始我们的<code>btcd</code>源码之旅。 <span id="more"></span></p>
<h2 id="i.-相关命令">I. 相关命令</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># start btcd</span></span><br><span class="line">./btcd -u seafooler -P 123456 --simnet --miningaddr=SRgBmewVAfaVzqKMPHeFYwkiAGD8jKBWFz</span><br><span class="line"></span><br><span class="line"><span class="comment"># start btcwallet</span></span><br><span class="line">./btcwallet -u seafooler -P 123456 --simnet</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate a new block</span></span><br><span class="line">./btcctl -u seafooler -P 123456 --wallet --simnet generate 1</span><br></pre></td></tr></table></figure>
<h2 id="ii.-btcctl中的相关源码">II. btcctl中的相关源码</h2>
<p><code>btcctl</code>源码位于<code>btcd</code>整个源码树中，但其是个相对独立的模块，主要位于<code>btcd/cmd/btcctl</code>路径下。</p>
<h3 id="a.-btcctl的main函数">A. btcctl的main函数</h3>
<p><code>btcctl</code>作为一个可执行程序，其必然存在<code>main</code>函数，在<code>btcctl.go</code>文件的L49. <code>main</code>函数的前半部分主要是读取一些配置信息，我们为保证源码分析思路的清晰，先不去讲解这些配置信息，只在后面用到这些配置信息的时候再进行讲解。我们在进入到一个函数时，只会讲解跟当前分析最相关的那些代码。也就是说，我们可能会在不同的分析场景下多次讲解同一个函数。 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main[btcctl.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;           <span class="comment">// L49</span></span><br><span class="line">    ...</span><br><span class="line">    cmd, err := btcjson.NewCmd(method, params...)           <span class="comment">// L107</span></span><br><span class="line">    ...</span><br><span class="line">    marshalledJSON, err := btcjson.MarshalCmd(<span class="number">1</span>, cmd)           <span class="comment">// L130</span></span><br><span class="line">    ...</span><br><span class="line">    result, err := sendPostRequest(marshalledJSON, cfg)           <span class="comment">// L138</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如上代码片段所示，<code>method</code>是从命令行参数中独取的, 利用<code>NewCmd</code>函数将其包装成一个<code>cmd</code>， 然后再利用<code>MarshalCmd</code>函数将其编码成<code>Json</code>格式，最后通过<code>sendPostRequest</code>函数将该命令发往<code>btcwallet</code>钱包进程。</p>
<h3 id="b.-newcmd的函数">B. NewCmd的函数</h3>
<p>我们先来观察一下这个<code>NewCmd</code>函数。该函数定义在<code>btcd/btcjson/cmdparser.go</code>文件中。也就是说，<code>btcctl</code>是和<code>btcd</code>中的其他模块共享的该文件。 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main[btcctl.go] -&gt; NewCmd[cmdparser.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCmd</span><span class="params">(method <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;           <span class="comment">// L511</span></span><br><span class="line">    ...</span><br><span class="line">    rtp, ok := methodToConcreteType[method]           <span class="comment">// L515</span></span><br><span class="line">    info := methodToInfo[method]            <span class="comment">// L516</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一段代码涉及到反射的许多知识，相对来说是比较难理解的。其中涉及到的反射细节，我会单独再用一个章节来讲解。这里只需要知道<code>method</code>是存储在一个<code>map</code>字典中，从中查询到相应的变量。</p>
<h3 id="c.-method的注册">C. method的注册</h3>
<p>我们再来看一下<code>generate</code>这个<code>method</code>是何时以及如何注册到上述的<code>map</code>字典中的。 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main[btcctl.go] -&gt; NewCmd[cmdparser.go] -&gt; init[btcdextcmds.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    MustRegisterCmd(<span class="string">&quot;generate&quot;</span>, (*GenerateCmd)(<span class="literal">nil</span>), flags)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main[btcctl.go] -&gt; NewCmd[cmdparser.go] -&gt; init[btcdextcmds.go] -&gt; MustRegisterCmd[register.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MustRegisterCmd</span><span class="params">(method <span class="keyword">string</span>, cmd <span class="keyword">interface</span>&#123;&#125;, flags UsageFlag)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := RegisterCmd(method, cmd, flags); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main[btcctl.go] -&gt; NewCmd[cmdparser.go] -&gt; init[btcdextcmds.go] -&gt; MustRegisterCmd[register.go] -&gt; RegisterCmd[register.go] </span></span><br><span class="line">methodToConcreteType = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]reflect.Type)</span><br><span class="line">methodToInfo         = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]methodInfo)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterCmd</span><span class="params">(method <span class="keyword">string</span>, cmd <span class="keyword">interface</span>&#123;&#125;, flags UsageFlag)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    rtp := reflect.TypeOf(cmd)</span><br><span class="line">    ...</span><br><span class="line">    methodToConcreteType[method] = rtp</span><br><span class="line">    methodToInfo[method] = methodInfo&#123;       </span><br><span class="line">        maxParams:    numFields,       </span><br><span class="line">        numReqParams: numFields - numOptFields,       </span><br><span class="line">        numOptParams: numOptFields,       </span><br><span class="line">        defaults:     defaults,       </span><br><span class="line">        flags:        flags,</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面三个代码片段可以看出，<code>generate</code>这个<code>method</code>是在<code>btcdextcmds.go</code>文件的初始化函数中被注册的。</p>
<h3 id="d.-sendpostrequest函数的实现">D. sendPostRequest函数的实现</h3>
<p>回到<code>btcctl</code>的<code>main</code>函数中来，我们来看一下<code>sendPostRequest</code>函数的实现细节。 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main[btcctl.go] -&gt;  sendPostRequest[httpclient.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendPostRequest</span><span class="params">(marshalledJSON []<span class="keyword">byte</span>, cfg *config)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    url := protocol + <span class="string">&quot;://&quot;</span> + cfg.RPCServer</span><br><span class="line">    bodyReader := bytes.NewReader(marshalledJSON)</span><br><span class="line">    httpRequest, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>, url, bodyReader)</span><br><span class="line">    ...</span><br><span class="line">    httpClient, err := newHTTPClient(cfg)</span><br><span class="line">    ...</span><br><span class="line">    httpResponse, err := httpClient.Do(httpRequest)</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码是我们比较熟悉的，就是以<code>POST</code>方式调用<code>url</code>，并将<code>Json</code>数据作为附加数据发送出去。该<code>url</code>的地址和端口号在<code>cfg.RPCServer</code>中定义，其在<code>main</code>函数的<code>loadConfig</code>函数中的<code>normalizeAddress</code>函数中完成了初始化，如下所示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main[btcctl.go] -&gt; loadConfig[config.go] -&gt; normalizeAddress[config.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">normalizeAddress</span><span class="params">(addr <span class="keyword">string</span>, useTestNet3, useSimNet, useWallet <span class="keyword">bool</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> useSimNet:</span><br><span class="line">        ...</span><br><span class="line">        defaultPort = <span class="string">&quot;18554&quot;</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>18554端口是<code>btcwallet</code>进程监听的端口号，接下来我们进入<code>btcwallet</code>进行分析。</p>
<h2 id="iii.-btcwallet中的相关代码">III. btcwallet中的相关代码</h2>
<p><code>btcwallet</code>具有两个职能：</p>
<ul>
<li>作为服务端，接收<code>btcctl</code>发过来的请求</li>
<li>作为客户端，向<code>btcd</code>发送请求</li>
</ul>
<p>同样地，<code>btcwallet</code>作为一个可以独立启动的进程，也必然是存在<code>main</code>函数的。而其<code>main</code>函数只是一个引子，其主要的功能代码都在<code>walletMain</code>函数中进行了实现。我们先来关注一下<code>walletMain</code>函数。 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// walletMain[btcwallet.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walletMain</span><span class="params">()</span> <span class="title">error</span></span> &#123;               <span class="comment">// L43</span></span><br><span class="line">    ...</span><br><span class="line">    rpcs, legacyRPCServer, err := startRPCServers(loader)                <span class="comment">// L77</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">go</span> rpcClientConnectLoop(legacyRPCServer, loader)                    <span class="comment">// L86</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中L77行的代码，主要实现了接收<code>btcctl</code>请求的服务端功能；而L86行的代码，主要实现了向<code>btcd</code>发送请求的客户端功能。</p>
<h3 id="a.-作为服务端的btcwallet">A. 作为服务端的btcwallet</h3>
<p>我们首先来看一下作为服务端的<code>btcwallet</code>是如何接收<code>btcctl</code>的请求的。 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// walletMain[btcwallet.go] -&gt; startRPCServers[rpcserver.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startRPCServers</span><span class="params">(walletLoader *wallet.Loader)</span> <span class="params">(*grpc.Server, *legacyrpc.Server, error)</span></span> &#123;             <span class="comment">// L105</span></span><br><span class="line">    ...</span><br><span class="line">    legacyServer = legacyrpc.NewServer(&amp;opts, walletLoader, listeners)               <span class="comment">// L168</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>功能主要是在L168行的<code>NewServer</code>函数中实现的。需要注意的是，尽管该函数名为"New..."，但服务端的启动也在该函数中完成了。代码如下所示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// walletMain[btcwallet.go] -&gt; startRPCServers[rpcserver.go] -&gt; NewServe[server.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(opts *Options, walletLoader *wallet.Loader, listeners []net.Listener)</span> *<span class="title">Server</span></span> &#123;      <span class="comment">// L90</span></span><br><span class="line">    ...</span><br><span class="line">    serveMux.Handle(<span class="string">&quot;/&quot;</span>, throttledFn(opts.MaxPOSTClients,       <span class="comment">// L117</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        server.postClientRPC(w, r)                                  <span class="comment">// L129</span></span><br><span class="line">        ...</span><br><span class="line">        &#125;))</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>NewServer</code>函数中L129行的<code>postClientRPC</code>函数用于接收<code>btcctl</code>的数据，并将数据进行处理后发往<code>btcd</code>，关键代码如下所示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// walletMain[btcwallet.go] -&gt; startRPCServers[rpcserver.go] -&gt; NewServe[server.go] -&gt; postClientRPC[server.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">postClientRPC</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;     <span class="comment">// L566</span></span><br><span class="line">    body := http.MaxBytesReader(w, r.Body, maxRequestSize)          <span class="comment">// L567</span></span><br><span class="line">    rpcRequest, err := ioutil.ReadAll(body)                             <span class="comment">// L568</span></span><br><span class="line">    ...</span><br><span class="line">    err = json.Unmarshal(rpcRequest, &amp;req)                         <span class="comment">// L581</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> req.Method &#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:       </span><br><span class="line">        res, jsonErr = s.handlerClosure(&amp;req)()&#125;                    <span class="comment">// L611</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>postClientRPC</code>函数中的前半部分用于从网络中读取并解析出"req"请求，并通过L611行进行处理。下面我们来看一下<code>handlerClosure</code>函数的实现细节： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// walletMain[btcwallet.go] -&gt; startRPCServers[rpcserver.go] -&gt; NewServe[server.go] -&gt; postClientRPC[server.go] -&gt; handlerClosure[server.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">handlerClosure</span><span class="params">(request *btcjson.Request)</span> <span class="title">lazyHandler</span></span>&#123;     <span class="comment">// L274</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> lazyApplyHandler(request, wallet, chainClient)                   <span class="comment">// L285</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再来看<code>lazyApplyHandler</code>的实现： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// walletMain[btcwallet.go] -&gt; startRPCServers[rpcserver.go] -&gt; NewServe[server.go] -&gt; postClientRPC[server.go] -&gt; handlerClosure[server.go] -&gt; lazyApplyHandler[methods.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lazyApplyHandler</span><span class="params">(request *btcjson.Request, w *wallet.Wallet, chainClient chain.Interface)</span> <span class="title">lazyHandler</span></span> &#123;     <span class="comment">// L168</span></span><br><span class="line">    handlerData, ok := rpcHandlers[request.Method]                          <span class="comment">// L169</span></span><br><span class="line">    <span class="keyword">if</span> ok &amp;&amp; handlerData.handlerWithChain != <span class="literal">nil</span> &amp;&amp; w != <span class="literal">nil</span> &amp;&amp; chainClient != <span class="literal">nil</span> &#123;            <span class="comment">// L170</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ok &amp;&amp; handlerData.handler != <span class="literal">nil</span> &amp;&amp; w != <span class="literal">nil</span> &#123;                   <span class="comment">// L192</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, *btcjson.RPCError)</span></span> &#123;                        <span class="comment">// L207</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> client := chainClient.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> *chain.RPCClient:</span><br><span class="line">            resp, err := client.RawRequest(request.Method, </span><br><span class="line">                request.Params)</span><br><span class="line">            ...</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>L169首先从<code>rpcHandlers</code>字典中查找是否有注册的<code>handler</code>，若有就直接调用该<code>handler</code>，但<code>generate</code>命令并没有注册相应的<code>handler</code> （后面我们会举<code>sendtoaddress</code>的例子，其在<code>rpcHandlers</code>中进行了注册）。因此，<code>lazyApplyHandler</code>函数中的代码将运行至L207中。我们来看看<code>RawRequest</code>函数的实现： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// walletMain[btcwallet.go] -&gt; startRPCServers[rpcserver.go] -&gt; NewServe[server.go] -&gt; postClientRPC[server.go] -&gt; handlerClosure[server.go] -&gt; lazyApplyHandler[methods.go] -&gt; RawRequest[rawrequest.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">RawRequest</span><span class="params">(method <span class="keyword">string</span>, params []json.RawMessage)</span> <span class="params">(json.RawMessage, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.RawRequestAsync(method, params).Receive()              <span class="comment">// L77</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>RawRequest</code>函数的实现很简单，只是做了一层函数的封装。但需要注意的是L77行末尾的<code>Receive()</code>调用。以下我们再分两个小节，分别讲解<code>RawRequestAsync</code>函数和<code>Receive</code>函数。</p>
<h4 id="rawrequestaync函数相关">1. RawRequestAync函数相关</h4>
<p>进一步查看<code>RawRequestAsync</code>函数： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// walletMain[btcwallet.go] -&gt; startRPCServers[rpcserver.go] -&gt; NewServe[server.go] -&gt; postClientRPC[server.go] -&gt; handlerClosure[server.go] -&gt; lazyApplyHandler[methods.go] -&gt; RawRequest[rawrequest.go] -&gt; RawRequestAsync[rawrequest.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">RawRequestAsync</span><span class="params">(method <span class="keyword">string</span>, params []json.RawMessage)</span> <span class="title">FutureRawResult</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    rawRequest := &amp;btcjson.Request&#123;       </span><br><span class="line">        Jsonrpc: <span class="string">&quot;1.0&quot;</span>,       </span><br><span class="line">        ID:      id,       </span><br><span class="line">        Method:  method,       </span><br><span class="line">        Params:  params,</span><br><span class="line">    &#125;</span><br><span class="line">    marshalledJSON, err := json.Marshal(rawRequest)</span><br><span class="line">    ...</span><br><span class="line">    responseChan := <span class="built_in">make</span>(<span class="keyword">chan</span> *response, <span class="number">1</span>)</span><br><span class="line">    jReq := &amp;jsonRequest&#123;       </span><br><span class="line">        id:             id,       </span><br><span class="line">        method:         method,       </span><br><span class="line">        cmd:            <span class="literal">nil</span>,       </span><br><span class="line">        marshalledJSON: marshalledJSON,       </span><br><span class="line">        responseChan:   responseChan,</span><br><span class="line">    &#125;</span><br><span class="line">    c.sendRequest(jReq)             <span class="comment">// L66</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> responseChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>RawRequestAsync</code>函数首先将数据封装成<code>jsonRequest</code>请求，然后通过L66行的<code>sendRequest</code>函数将该请求发送出去。注意到<code>RawRequestAsync</code>函数返回的是<code>FutureRawResult</code>类型的变量，其会在III.A.2节中重点讲解。 <code>sendRequest</code>函数的实现细节如下所示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// walletMain[btcwallet.go] -&gt; startRPCServers[rpcserver.go] -&gt; NewServe[server.go] -&gt; postClientRPC[server.go] -&gt; handlerClosure[server.go] -&gt; lazyApplyHandler[methods.go] -&gt; RawRequest[rawrequest.go] -&gt; RawRequestAsync[rawrequest.go] -&gt; sendRequest[infrastructure.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">sendRequest</span><span class="params">(jReq *jsonRequest)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    c.sendMessage(jReq.marshalledJSON)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再来看<code>sendMessage</code>函数： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// walletMain[btcwallet.go] -&gt; startRPCServers[rpcserver.go] -&gt; NewServe[server.go] -&gt; postClientRPC[server.go] -&gt; handlerClosure[server.go] -&gt; lazyApplyHandler[methods.go] -&gt; RawRequest[rawrequest.go] -&gt; RawRequestAsync[rawrequest.go] -&gt; sendRequest[infrastructure.go] -&gt; sendMessage[infrastructure.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">sendMessage</span><span class="params">(marshalledJSON []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> c.sendChan &lt;- marshalledJSON:          <span class="comment">// L481</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-c.disconnectChan():</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sendMessage</code>函数中将数据发送往<code>sendChan</code>管道，用于激活III.B节中<code>wsOutHandler</code>函数中阻塞的L449行代码。需要注意的是，<strong><code>RawRequestAync</code>函数并没有直接将数据发送到<code>btcd</code>中，而是将数据发往<code>sendChan</code>管道。III.B.1.2节中的<code>wsOutHandler</code>函数才会真正将数据发往<code>btcd</code></strong>。</p>
<h4 id="receive函数相关">2. Receive函数相关</h4>
<p>回到<code>RawRequest</code>函数中L77行末尾的<code>Receive()</code>调用。 <strong>准确来说，<code>Receive</code>函数已经不完全属于"服务端"的职能了，因为该函数用于接收从<code>btcd</code>返回的数据（如新生成的区块的hash值）。但其并没有直接与<code>btcd</code>打交道，而是通过<code>FutureRawResult</code>管道接收返回值。和<code>btcd</code>打交道的工作是由下一篇博客中的III.B.1.1小节的<code>wsInHandler</code>函数完成，该函数进一步激活了<code>FutureRawResult</code>管道。</strong> 前面已经提及<code>RawRequestAsync</code>函数返回的是<code>FutureRawResult</code>类型的变量。 下面我们关注一下<code>FutureRawResult</code>类型以及其<code>Receive</code>方法。 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// walletMain[btcwallet.go] -&gt; startRPCServers[rpcserver.go] -&gt; NewServe[server.go] -&gt; postClientRPC[server.go] -&gt; handlerClosure[server.go] -&gt; lazyApplyHandler[methods.go] -&gt; RawRequest[rawrequest.go] -&gt; rawrequest.go</span></span><br><span class="line"><span class="keyword">type</span> FutureRawResult <span class="keyword">chan</span> *response</span><br></pre></td></tr></table></figure></p>
<p>注意到，<code>FutureRawResult</code>只是一个<code>chan</code>类型的重命名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// walletMain[btcwallet.go] -&gt; startRPCServers[rpcserver.go] -&gt; NewServe[server.go] -&gt; postClientRPC[server.go] -&gt; handlerClosure[server.go] -&gt; lazyApplyHandler[methods.go] -&gt; RawRequest[rawrequest.go] -&gt; Receive[rawrequest.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r FutureRawResult)</span> <span class="title">Receive</span><span class="params">()</span> <span class="params">(json.RawMessage, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> receiveFuture(r)           <span class="comment">// L21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数也只是对<code>receiveFuture</code>函数进行了一层封装，<code>receiveFuture</code>函数的实现如下所示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// walletMain[btcwallet.go] -&gt; startRPCServers[rpcserver.go] -&gt; NewServe[server.go] -&gt; postClientRPC[server.go] -&gt; handlerClosure[server.go] -&gt; lazyApplyHandler[methods.go] -&gt; RawRequest[rawrequest.go] -&gt; Receive[rawrequest.go] -&gt; receiveFuture[infrastructure.go]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveFuture</span><span class="params">(f <span class="keyword">chan</span> *response)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    r := &lt;-f                <span class="comment">// L797</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> L797行形成了<code>chan</code>的阻塞，该阻塞将在III.B节的<code>wsInHandler</code>函数中被激活。</p>
<h3 id="b.-作为客户端的btcwallet">B. 作为客户端的btcwallet</h3>
<p>为避免这一篇博客过长，III.B节的内容将放在下一篇<a target="_blank" rel="noopener" href="https://seafooler.github.io/2019/01/23/btcd-source-code-analysis-2/">博客</a>中。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Blockchain/" rel="tag"># Blockchain</a>
              <a href="/tags/Bitcoin/" rel="tag"># Bitcoin</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/01/21/btcd-source-code-analysis-0/" rel="prev" title="btcd源码解析 (0)">
      <i class="fa fa-chevron-left"></i> btcd源码解析 (0)
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/01/23/btcd-source-code-analysis-2/" rel="next" title="btcd源码解析——从“新区块的生成”开始 (2)">
      btcd源码解析——从“新区块的生成”开始 (2) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#i.-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">1.</span> <span class="nav-text">I. 相关命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ii.-btcctl%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81"><span class="nav-number">2.</span> <span class="nav-text">II. btcctl中的相关源码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a.-btcctl%E7%9A%84main%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">A. btcctl的main函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b.-newcmd%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">B. NewCmd的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c.-method%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-number">2.3.</span> <span class="nav-text">C. method的注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d.-sendpostrequest%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.4.</span> <span class="nav-text">D. sendPostRequest函数的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iii.-btcwallet%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="nav-number">3.</span> <span class="nav-text">III. btcwallet中的相关代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a.-%E4%BD%9C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84btcwallet"><span class="nav-number">3.1.</span> <span class="nav-text">A. 作为服务端的btcwallet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rawrequestaync%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3"><span class="nav-number">3.1.1.</span> <span class="nav-text">1. RawRequestAync函数相关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#receive%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3"><span class="nav-number">3.1.2.</span> <span class="nav-text">2. Receive函数相关</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b.-%E4%BD%9C%E4%B8%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84btcwallet"><span class="nav-number">3.2.</span> <span class="nav-text">B. 作为客户端的btcwallet</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Seafooler</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:seafooler@gmail.com" title="E-Mail → mailto:seafooler@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Seafooler</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : ,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>












  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
