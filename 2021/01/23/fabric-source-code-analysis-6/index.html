<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-kelp.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-kelp.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-kelp.png">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":{"disqus":{"text":"Load Disqus","order":-1}}},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本篇博客是继续对Hyperledger Fabric中的PBFT代码进行解读，重点关注checkpoint机制的实现。">
<meta property="og:type" content="article">
<meta property="og:title" content="Fabric中PBFT源码解读——Checkpoint机制">
<meta property="og:url" content="http://example.com/2021/01/23/fabric-source-code-analysis-6/index.html">
<meta property="og:site_name" content="Seafooler&#39;s Blog">
<meta property="og:description" content="本篇博客是继续对Hyperledger Fabric中的PBFT代码进行解读，重点关注checkpoint机制的实现。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210123203628701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ2MzMyODM=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="article:published_time" content="2021-01-22T16:00:00.000Z">
<meta property="article:modified_time" content="2022-01-05T13:09:38.849Z">
<meta property="article:author" content="Seafooler">
<meta property="article:tag" content="Blockchain">
<meta property="article:tag" content="PBFT">
<meta property="article:tag" content="Fabric">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20210123203628701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ2MzMyODM=,size_16,color_FFFFFF,t_70#pic_center">

<link rel="canonical" href="http://example.com/2021/01/23/fabric-source-code-analysis-6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Fabric中PBFT源码解读——Checkpoint机制 | Seafooler's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Seafooler's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/23/fabric-source-code-analysis-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seafooler">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seafooler's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Fabric中PBFT源码解读——Checkpoint机制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-23 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-23T00:00:00+08:00">2021-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-05 21:09:38" itemprop="dateModified" datetime="2022-01-05T21:09:38+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Code-analysis/" itemprop="url" rel="index"><span itemprop="name">Code-analysis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本篇博客是继续对<code>Hyperledger Fabric</code>中的<code>PBFT</code>代码进行解读，重点关注<code>checkpoint</code>机制的实现。 <span id="more"></span></p>
<h2 id="i.-写在前面">I. 写在前面</h2>
<h3 id="a.-前置阅读">A. 前置阅读</h3>
<p>本篇博客是建立在之前一些博客的基础上。一切重复的知识介绍，笔者在这篇博客中就不再赘述了。 因此，强烈建议读者先去阅读一下以下这几篇博客。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014633283/article/details/112307024">Fabric中PBFT源码解读 （1）</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014633283/article/details/112308084">Fabric中PBFT源码解读 （2）</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014633283/article/details/112344708">Fabric中PBFT源码解读 （3）</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014633283/article/details/112346508">Fabric中PBFT源码解读 （4）</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014633283/article/details/112364913">Fabric中PBFT源码解读 （5）</a></li>
</ul>
<h3 id="b.-对testcheckpoint函数的测试">B. 对TestCheckpoint函数的测试</h3>
<p>和博客<a target="_blank" rel="noopener" href="https://blog.csdn.net/u014633283/article/details/112307024">Fabric中PBFT源码解读（1）</a>中的类似，本篇博客主要介绍<code>pbft-core_test.go</code>中<code>TestCheckpoint</code>函数对<code>PBFT</code>功能的测试。该功能主要指<code>PBFT</code>中的<code>Checkpoint</code>。 <code>TestCheckpoint</code>函数主要分为两部分，第一部分（L297~L330行）是对简单的<code>Checkpoint</code>生成进行测试，第二部分（L332~L361行）测试<code>Water mark</code>对<code>ReqBatch</code>执行的影响。但第二部分的测试代码貌似有点问题。而且整个<code>TestCheckpoint</code>函数中定义的两个<code>WaitGroup</code>类型的变量<code>execWait</code>和<code>finishWait</code>也挺令人费解的。。。。。。</p>
<p>因此，本篇博客主要关注第一部分的测试，并且忽略<code>execWait</code>和<code>finishWait</code>变量。</p>
<p>总体而言，<code>Checkpoint</code>主要会影响1）节点中<code>Water mark</code>的更新和2）集群中<code>View</code>的切换。由于<code>View</code>的切换比较复杂，笔者会专门用一篇博客进行介绍。因此，本篇博客主要介绍<code>Checkpoint</code>生成以及<code>Water mark</code>的更新。</p>
<h2 id="ii.-对testcheckpoint函数运行流程的解读">II. 对TestCheckpoint函数运行流程的解读</h2>
<p><code>TestCheckpoint</code>函数的主体代码如下所示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [pbft-core_test.go] TestCheckpoint</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCheckpoint</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    validatorCount := <span class="number">4</span></span><br><span class="line">    config := loadConfig()</span><br><span class="line">    config.Set(<span class="string">&quot;general.K&quot;</span>, <span class="number">2</span>)                          <span class="comment">// L299</span></span><br><span class="line">    config.Set(<span class="string">&quot;general.logmultiplier&quot;</span>, <span class="number">2</span>)               <span class="comment">// L300</span></span><br><span class="line">    net := makePBFTNetwork(validatorCount, config)</span><br><span class="line">    <span class="keyword">defer</span> net.stop()</span><br><span class="line">    </span><br><span class="line">    execReqBatch := <span class="function"><span class="keyword">func</span><span class="params">(tag <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    net.pbftEndpoints[<span class="number">0</span>].manager.Queue() &lt;- createPbftReqBatch(tag, <span class="keyword">uint64</span>(generateBroadcaster(validatorCount)))</span><br><span class="line">		net.process()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// execWait is 0, and execute will proceed</span></span><br><span class="line">	execReqBatch(<span class="number">1</span>)                                     <span class="comment">// L310</span></span><br><span class="line">	execReqBatch(<span class="number">2</span>)                                     <span class="comment">// L311</span></span><br><span class="line">	...</span><br><span class="line">	net.process()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这里的代码跟博客<code>TestNetwork</code>大同小异，主要的不同包括<code>general.K</code>和<code>general.logmultiplier</code>两个参数的设置，以及对<code>reqBatch</code>的请求发送进行了一个函数封装（也即<code>execReqBatch</code>函数）。</p>
<h3 id="a.-checkpoint和water-mark的概念解释">A. Checkpoint和Water mark的概念解释</h3>
<p>为解释<code>general.K</code>和<code>general.logmultiplier</code>两个参数，我们首先介绍一下PBTF节点中的日志存储。<code>PBTF</code>中的每一条执行请求都会以日志的形式记录在节点中。但这些日志不能无限增长，必须采用某种方式进行日志的缩减（也即OSDI'99论文中Section 4.3 Garbage Collection中所介绍的）。为实现日志删减，<code>PBFT</code>中定义了<code>Checkpoint</code>的概念，并将在2f+1个节点中都达成了的<code>Checkpoint</code>称为<code>Stable checkpoint</code>。基于<code>Stable checkpoint</code>，<code>PBFT</code>中还定义了<code>Water mark</code>的概念。<code>Water mark</code>可以被看作是一个序列号窗口，包括<code>low-water mark</code>和<code>high-water mark</code>。其中<code>low-water mark</code>为<code>Stable checkpoint</code>中包含的最高的请求序列号。</p>
<p>因此，<code>Water mark</code>随着<code>Checkpoint</code>往前动态推移。同时，<code>Water mark</code>还规定了当前能够被接收执行的请求的序列号。具体而言，由于<code>low-water mark</code>表示了已被<code>Stable checkpoint</code>确认的序列号，因而低于该<code>low-water mark</code>的请求将不予执行。同时，高于<code>high-water mark</code>的请求也将不予执行。下图展示了<code>Checkpoint</code>和<code>Water mark</code>的示意图。<code>PBFT</code>中要求<code>Water mark</code>的大小必须为<code>Checkpoint</code>大小的整数倍。如下图中，<code>Checkpoint</code>的大小为6，<code>Water mark</code>的大小为18。 <img src="https://img-blog.csdnimg.cn/20210123203628701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ2MzMyODM=,size_16,color_FFFFFF,t_70#pic_center" alt="Checkpoint和Water mark的示意图" /></p>
<p>回到<code>TestCheckpoint</code>函数中，<code>general.K</code>定义了<code>Checkpoint</code>的大小，<code>general.logmultiplier</code>定义了<code>Water mark</code>中可容纳的<code>Checkpoint</code>的个数。也即<code>Water mark</code>的大小为<code>general.K</code>*<code>general.logmultiplier</code>。</p>
<p><code>TestCheckpoint</code>函数在L299行和L300行分别定义了<code>general.K</code>和<code>general.logmultiplier</code>的值为2。也即：每隔两个请求，节点将生成一个<code>Checkpoint</code>。</p>
<p>另一方面，L310行和L311行恰好发起了两个执行请求。因此，预计测试结果中将生成一个<code>Checkpoint</code>。 以下，我们再此回顾请求的执行过程，重点关注函数调用中与<code>Checkpoint</code>和<code>Water mark</code>相关的部分。</p>
<h3 id="b.-sendpreprepare函数中对sequence的检查">B. sendPrePrepare函数中对sequence的检查</h3>
<p>回顾之前博客中的内容，L310行中发出的请求将由<code>sendPrePrepare</code>函数接收并处理，该函数及相关函数的代码如下所示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [pbft-core.go] sendPrePrepare</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(instance *pbftCore)</span> <span class="title">sendPrePrepare</span><span class="params">(reqBatch *RequestBatch, digest <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> !instance.inWV(instance.view, n) || n &gt; instance.h+instance.L/<span class="number">2</span> &#123;     <span class="comment">// L643</span></span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(instance *pbftCore)</span> <span class="title">inWV</span><span class="params">(v <span class="keyword">uint64</span>, n <span class="keyword">uint64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> instance.view == v &amp;&amp; instance.inW(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(instance *pbftCore)</span> <span class="title">inW</span><span class="params">(n <span class="keyword">uint64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n-instance.h &gt; <span class="number">0</span> &amp;&amp; n-instance.h &lt;= instance.L</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>sendPrePrepare</code>函数主要在L643行对请求的<code>sequence</code> <code>n</code>进行了两部分检查。</p>
<p>第一部分主要调用了<code>inWV</code>函数，后者又主要调用了<code>inW</code>函数。这里需要提及的事，<code>Fabric</code>对<code>PBFT</code>的具体实现中，只定义了<code>low-water mark</code>的值和<code>Water mark</code>的大小。前者即为<code>instance.h</code>，后者为<code>instance.L</code>。因此，在<code>inW</code>函数中，实际上便对请求的序列号进行了<code>low-water mark</code>和<code>high-water mark</code>的检查。</p>
<p>第二部分的检查对<code>n</code>再次进行了检查。当请求的序列号超过当前<code>water mark</code>的中位值时，也不会发送当前请求。这一点其实是有点让人费解的，我们姑且认为其是做了一个更为保守的检查操作吧。</p>
<h3 id="c.-commit请求时生成checkpoint">C. Commit请求时生成Checkpoint</h3>
<p>在前面的博客中介绍到：在<code>recvCommit</code>函数中如果判断已经达到了<code>committed</code>的状态，将调用<code>executeOutstanding</code>函数。为唤起读者的记忆，相关代码摘录如下： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [pbft-core.go] recvCommit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(instance *pbftCore)</span> <span class="title">recvCommit</span><span class="params">(commit *Commit)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> instance.committed(commit.BatchDigest, commit.View, commit.SequenceNumber) &#123;</span><br><span class="line">    ...</span><br><span class="line">    instance.executeOutstanding()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>executeOutstanding</code>函数进一步调用<code>pbftCore.executeOne</code>函数、<code>simpleConsumer.execute</code>函数。<code>execute</code>函数中向<code>Event</code>管道中传入了<code>execDoneEvent</code>类型的消息，如下代码所示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [pbft-core_mock_test.go]execute</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *simpleConsumer)</span> <span class="title">execute</span><span class="params">(seqNo <span class="keyword">uint64</span>, reqBatch *RequestBatch)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, req := <span class="keyword">range</span> reqBatch.GetBatch() &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; sc.pe.manager.Queue() &lt;- execDoneEvent&#123;&#125; &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 该消息在<code>managerImpl.eventLoop</code>函数中被接收，后者接着调用<code>managerImpl.Inject</code>函数、<code>SendEvent</code>函数将该消息传送到<code>pbftCore.ProcessEvent</code>函数中。<code>pbftCore.ProcessEvent</code>函数中的相关代码如下所示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [pbft-core_mock_test.go]execute -&gt; .... -&gt; [pbft-core.go] ProcessEvent</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(instance *pbftCore)</span> <span class="title">ProcessEvent</span><span class="params">(e events.Event)</span> <span class="title">events</span>.<span class="title">Event</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> et := e.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> execDoneEvent:</span><br><span class="line">        instance.execDoneSync()                               <span class="comment">// L386</span></span><br><span class="line">        ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>ProcessEvent</code>函数在L386行调用了<code>execDoneSync</code>函数，后者的相关代码如下： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [pbft-core_mock_test.go]execute -&gt; .... -&gt; [pbft-core.go] ProcessEvent -&gt; execDoneSync</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(instance *pbftCore)</span> <span class="title">execDoneSync</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> instance.currentExec != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> instance.lastExec%instance.K == <span class="number">0</span> &#123;                  <span class="comment">// L996</span></span><br><span class="line">            instance.Checkpoint(instance.lastExec, instance.consumer.getState())</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 从L996行容易看到，若当前执行的请求序列号<code>lastExec</code>是<code>K</code>的整数倍，即被认定为需要进行<code>Checkpoint</code>，从而调用<code>pbftCore.Checkpoint</code>函数。<code>Checkpoint</code>函数的主体代码如下所示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [pbft-core_mock_test.go]execute -&gt; .... -&gt; [pbft-core.go] ProcessEvent -&gt; execDoneSync -&gt; Checkpoint</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(instance *pbftCore)</span> <span class="title">Checkpoint</span><span class="params">(seqNo <span class="keyword">uint64</span>, id []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    chkpt := &amp;Checkpoint&#123;                                     <span class="comment">// L980</span></span><br><span class="line">		SequenceNumber: seqNo,</span><br><span class="line">		ReplicaId:      instance.id,</span><br><span class="line">		Id:             idAsString,</span><br><span class="line">	&#125;                                                       <span class="comment">// L984</span></span><br><span class="line">	...</span><br><span class="line">    instance.recvCheckpoint(chkpt)                            <span class="comment">// L988</span></span><br><span class="line">    instance.innerBroadcast(&amp;Message&#123;Payload: &amp;Message_Checkpoint&#123;Checkpoint: chkpt&#125;&#125;)                       <span class="comment">// L989</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> L980至L984行定义了一个<code>Checkpoint</code>类型的变量<code>chkpt</code>，L988行将该变量发送给了自己，L989行将该变量广播给了其他节点。 这里我们先看<code>innerBroadcast</code>函数。这里的<code>innerBroadcast</code>函数调用和前面博客中的<code>innerBroadcast</code>调用大同小异，最终都将转发到其他节点中的<code>pbftCore.ProcessEvent</code>中来接收。<code>pbftCore.ProcessEvent</code>函数的相关代码如下： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [pbft-core.go] ProcessEvent</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(instance *pbftCore)</span> <span class="title">ProcessEvent</span><span class="params">(e events.Event)</span> <span class="title">events</span>.<span class="title">Event</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> et := e.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> *Checkpoint:</span><br><span class="line">		<span class="keyword">return</span> instance.recvCheckpoint(et)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 容易发现，<code>ProcessEvent</code>在接收到<code>Checkpoint</code>类型的消息后也是调用了<code>recvCheckpoint</code>函数。以下我们重点来关注<code>recvCheckpoint</code>函数。</p>
<h3 id="d.-recvcheckpoint函数的实现细节1">D. recvCheckpoint函数的实现细节（1）</h3>
<p><code>recvCheckpoint</code>函数的主体代码如下所示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [pbft-core.go] recvCheckpoint</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(instance *pbftCore)</span> <span class="title">recvCheckpoint</span><span class="params">(chkpt *Checkpoint)</span> <span class="title">events</span>.<span class="title">Event</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> instance.weakCheckpointSetOutOfRange(chkpt) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>recvCheckpoint</code>函数首先调用了<code>weakCheckpointSetOutOfRange</code>函数。后者主要用来判断，当前<code>checkpoint</code>是否超过了<code>high-water mark</code>。并结合已经存储的超过<code>high-water mark</code>的<code>checkpoint</code>个数，来判断当前节点的状态是否确实落后了。我们首先来看一下<code>weakCheckpointSetOutOfRange</code>函数。 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [pbft-core.go] recvCheckpoint -&gt; weakCheckpointSetOutOfRange</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(instance *pbftCore)</span> <span class="title">weakCheckpointSetOutOfRange</span><span class="params">(chkpt *Checkpoint)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    H := instance.h + instance.L</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> chkpt.SequenceNumber &lt; H &#123;                             <span class="comment">// L1063</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">delete</span>(instance.hChkpts, chkpt.ReplicaId)              <span class="comment">// L1065</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        instance.hChkpts[chkpt.ReplicaId] = chkpt.SequenceNumber <span class="comment">// L1069</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(instance.hChkpts) &gt;= instance.f+<span class="number">1</span> &#123;             <span class="comment">// L1073</span></span><br><span class="line">            chkptSeqNumArray := <span class="built_in">make</span>([]<span class="keyword">uint64</span>, <span class="built_in">len</span>(instance.hChkpts)) <span class="comment">// L1074</span></span><br><span class="line">            index := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> replicaID, hChkpt := <span class="keyword">range</span> instance.hChkpts &#123;</span><br><span class="line">                chkptSeqNumArray[index] = hChkpt</span><br><span class="line">                index++</span><br><span class="line">                <span class="keyword">if</span> hChkpt &lt; H &#123;</span><br><span class="line">                    <span class="built_in">delete</span>(instance.hChkpts, replicaID)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;                                              <span class="comment">// L1082</span></span><br><span class="line">            sort.Sort(sortableUint64Slice(chkptSeqNumArray))    <span class="comment">// L1083</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> m := chkptSeqNumArray[<span class="built_in">len</span>(chkptSeqNumArray)-(instance.f+<span class="number">1</span>)]; m &gt; H &#123;                                     <span class="comment">// L1088</span></span><br><span class="line">                ...</span><br><span class="line">                instance.moveWatermarks(m)                    <span class="comment">// L1092</span></span><br><span class="line">                ...</span><br><span class="line">                instance.skipInProgress = <span class="literal">true</span>                <span class="comment">// L1094</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>                                 <span class="comment">// L1100</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>                                            <span class="comment">// L1105</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>weakCheckpointSetOutOfRange</code>函数看起来比较复杂，但整体逻辑还是比较简单的。主要分为两个部分：</p>
<ul>
<li>1）L1063行的判断为真时，说明<code>chkpt中SequenceNumber</code>并未超过<code>high-water mark</code>，当然也就不会得到节点状态确实落后的结论，从而在L1105行返回<code>false</code>。如下所述，只有当超过f+1个节点发来的<code>chkpt</code>都超过了<code>high-water mark</code>，才说明当前节点确实落后了。此外，需要提一下L1065行的操作。L1065行使用了一个<code>hChkpts</code>字段，该字段中主要保存了所有超过<code>high-water mark</code>的<code>checkpoint</code>。因此，当一个节点发来的<code>chkpt</code>中的<code>SequenceNumber</code>并未超过<code>high-water mark</code>时，将尝试对<code>hChkpts</code>字段进行删除更新操作。</li>
<li>2）L1063行的判断为假时，将进一步判断：超过<code>high-water mark</code>的<code>checkpoint</code>数量是否已经超过f+1个。首先在L1069行将当前<code>chkpt</code>保存在hChkpts字段中。L1073行对<code>hChkpts</code>字段中保存的<code>checkpoint</code>数量进行了一个初步判断。L1074至L1082行对<code>hChkpts</code>字段中保存的内容进行了一次重新组织，包括将其中已经小于<code>high-water mark</code>的值删除，并将其余值的<code>hChkpt</code>（其实是<code>SequenceNumber</code>）保存在一个新的<code>chkptSeqNumArray</code>变量中。L1083行对<code>chkptSeqNumArray</code>变量进行了排序。L1088行对<code>chkptSeqNumArray</code>中处于倒数第f+1位置的值进行了判断：判断其是否超过了high-water mark。这里的逻辑是这样的：由于<code>chkptSeqNumArray</code>中的值已经是递增有序的了，当倒数第f+1位置的值都大于<code>high-water mark</code>，则说明其中至少有f+1个位置的值都大于<code>high-water mark</code>。</li>
</ul>
<p>乍一看可能会觉得L1074至L1088行的代码有些冗余：不就相当于在删除了小于<code>high-water mark</code>的<code>checkpoint</code>后又判断了一次这些<code>checkpoint</code>的数目嘛。其实这段代码还有一个很重要的作用，就是找到倒数第f+1个<code>checkpoint</code>的<code>SequenceNumber</code>值，也即<code>m</code>。该<code>m</code>在L1092行用于更新<code>Water mark</code>。</p>
<p>剩下来的就比较简单了，在L1092行对<code>Water mark</code>进行了更新，在L1094行将<code>skipInProgress</code>变量设置为<code>true</code>，并返回true。 先说一下<code>skipInProgress</code>变量，其主要被用来作为状态同步的依据。当该值为<code>true</code>时，节点将在后面进行状态同步。</p>
<p>下面再来看一下L1092行的<code>moveWatermarks</code>函数，其函数主体如下所示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [pbft-core.go] recvCheckpoint -&gt; weakCheckpointSetOutOfRange -&gt; moveWatermarks</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(instance *pbftCore)</span> <span class="title">moveWatermarks</span><span class="params">(n <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// round down n to previous low watermark</span></span><br><span class="line">    h := n / instance.K * instance.K                <span class="comment">// L1010</span></span><br><span class="line">    ...</span><br><span class="line">    instance.h = h                                <span class="comment">// L1049</span></span><br><span class="line">    ...</span><br><span class="line">    instance.resubmitRequestBatches()               <span class="comment">// L1054</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>moveWatermarks</code>函数主要干了四件事：</p>
<ol type="1">
<li>计算出新的<code>low-water mark</code>。L1010行乍一看是行没用的代码，但其中实现了一些巧妙的运算。由于我们传入的n是某一个<code>Checkpoint</code>中的最大<code>SequenceNumber</code>。该<code>SequenceNumber</code>一般可以表示为<code>instance.K</code>*<code>m</code>+(<code>instance.K</code>-1)的形式。通过L1010行的计算，得到<code>instance.K</code>*<code>m</code>，该值即为该<code>checkpoint</code>的<code>low-water mark</code>。举例来说，假设<code>instance.K</code>为6，<code>Checkpoint</code>中包含的<code>SequenceNumber</code>区间将可能是[0, 5], [6, 11], [12, 17] ...对于[12, 17]的<code>Checkpoint</code>，其传入的<code>n</code>为17，经过L1010行的计算17/6*6得到值12，即为该<code>Checkpoint</code>的<code>low-water mark</code>.</li>
<li>删除小于新的<code>low-water mark</code>的数据。由于这些代码比较长（从L1011行到L1048行），考虑到篇幅，笔者没有在上面代码中列出。这些删除操作包括删除<code>certStore</code>、<code>checkpointStore</code>、<code>pset</code>、<code>qset</code>、<code>chkpts</code>中存储的各种数据。</li>
<li>更新节点的<code>low-water mark</code> 。L1049实现了该操作。</li>
<li>重新提交被积压的请求。如L1054行所示。</li>
</ol>
<h3 id="e.-recvcheckpoint函数的实现细节2">E. recvCheckpoint函数的实现细节（2）</h3>
<p>重新回到<code>recvCheckpoint</code>函数，相关代码如下所示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [pbft-core.go] recvCheckpoint</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(instance *pbftCore)</span> <span class="title">recvCheckpoint</span><span class="params">(chkpt *Checkpoint)</span> <span class="title">events</span>.<span class="title">Event</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> instance.weakCheckpointSetOutOfRange(chkpt) &#123;            <span class="comment">// L1147</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>                                           <span class="comment">// L1148</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> !instance.inW(chkpt.SequenceNumber) &#123;                   <span class="comment">// L1151</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>                                          </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    instance.checkpointStore[*chkpt] = <span class="literal">true</span>                    <span class="comment">// L1161</span></span><br><span class="line">    ...</span><br><span class="line">    diffValues := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)                    <span class="comment">// L1164</span></span><br><span class="line">    diffValues[chkpt.Id] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    matching := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> testChkpt := <span class="keyword">range</span> instance.checkpointStore &#123;</span><br><span class="line">        <span class="keyword">if</span> testChkpt.SequenceNumber == chkpt.SequenceNumber &#123;</span><br><span class="line">			<span class="keyword">if</span> testChkpt.Id == chkpt.Id &#123;</span><br><span class="line">				matching++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> _, ok := diffValues[testChkpt.Id]; !ok &#123;</span><br><span class="line">					diffValues[testChkpt.Id] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;                                                       <span class="comment">// L1178</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> count := <span class="built_in">len</span>(diffValues); count &gt; instance.f+<span class="number">1</span> &#123;         <span class="comment">// L1183</span></span><br><span class="line">		logger.Panicf(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> matching == instance.f+<span class="number">1</span> &#123;                             <span class="comment">// L1188</span></span><br><span class="line">		...</span><br><span class="line">		instance.witnessCheckpointWeakCert(chkpt)               <span class="comment">// L1197</span></span><br><span class="line">	&#125;                                                       <span class="comment">// L1198</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> matching &lt; instance.intersectionQuorum() &#123;               <span class="comment">// L1200</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> _, ok := instance.chkpts[chkpt.SequenceNumber]; !ok &#123;     <span class="comment">// L1213</span></span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> instance.skipInProgress &#123;                           <span class="comment">// L1216</span></span><br><span class="line">			logSafetyBound := instance.h + instance.L/<span class="number">2</span></span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">if</span> chkpt.SequenceNumber &gt;= logSafetyBound &#123;         <span class="comment">// L1220</span></span><br><span class="line">				...</span><br><span class="line">				instance.moveWatermarks(chkpt.SequenceNumber)    <span class="comment">// L1222</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">    instance.moveWatermarks(chkpt.SequenceNumber)               <span class="comment">// L1231</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> instance.processNewView()                          <span class="comment">// L1233</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如上一小节所述，如果<code>weakCheckpointSetOutOfRange</code>函数返回为<code>true</code>，说明当前节点的数据状态落后太多了，需要首先进行状态同步。也就没有必要再进行这一次的<code>Checkpoint</code>的操作了，直接在L1148行返回。 以下介绍<code>weakCheckpointSetOutOfRange</code>函数返回为<code>false</code>的情形。</p>
<ol type="1">
<li>L1151行对当前<code>chkpt</code>的<code>SequenceNumber</code>进行了检查，如果不在<code>watermark</code>范围内，则直接返回。</li>
<li>L1161行将接收到的<code>Checkpoint</code>存储到<code>checkpointStore</code>中。<code>checkpointStore</code>中存储了所有接收到的<code>Checkpoint</code>。</li>
<li>接下来的L1164到L1178行基于<code>checkpointStore</code>变量，构建了两个新变量<code>diffValues</code>和<code>matching</code>。其中matching变量统计了和当前<code>chkpt</code>的<code>SequenceNumber</code>和<code>Id</code>都相同的<code>checkpoint</code>的数量，<code>diffValues</code>变量保存了和当前<code>chkpt</code>的<code>SequenceNumber</code>相同但<code>Id</code>不同的<code>Checkpoint</code>的<code>Id</code>值。</li>
<li>L1183行对<code>diffValues</code>进行了检查。如果<code>diffValues</code>中保存的<code>Id</code>数量超过f+1个，说明和<code>chkpt</code>的<code>SequenceNumber</code>及<code>Id</code>都相同的<code>checkpoint</code>的数量最多不超过2f个，因而<code>chkpt</code>永远不可能成为<code>stable checkpoint</code>。更重要的是，一般而言：<code>SequenceNumber</code>相同的<code>Checkpoint</code>对应的<code>Id</code>（<code>Id</code>表示一个节点当前的数据状态）应该也是相同的。这里有超过f+1个<code>Checkpoint</code>的<code>Id</code>（也即数据状态）不同，其中至少有一个诚实节点和当前节点的数据状态不同，说明集群中出现了问题，因此直接采用<code>panic</code>函数报错。</li>
<li>L1188行判断<code>matching</code>值是否为f+1。若是，则调用<code>witnessCheckpointWeakCert</code>函数。<code>witnessCheckpointWeakCert</code>函数主要是用来辅助节点的状态更新的。因此，整体L1188至L1198行的逻辑是这样的：当当前节点收到f+1个具有相同<code>SequenceNumber</code>和<code>Id</code>的<code>Checkpoint</code>时，该<code>Checkpoint</code>大概率代表了一个稳定的数据状态，调用<code>witnessCheckpointWeakCert</code>函数尝试将当前节点的状态更新到该数据状态。笔者这里思考过一个问题：为什么是判断等于f+1，而不是大于等于f+1。笔者的理解是：对<code>witnessCheckpointWeakCert</code>函数的调用一次就够了，没必要在大于等于f+1的每次都调用该函数。</li>
<li>L1200行对<code>matching</code>值再次进行了判断。若未达到<code>Quorum</code>（即2f+1），则说明<code>chkpt</code>对应的<code>Checkpoint</code>未达到稳定，直接返回；否则，说明<code>chkpt</code>对应的<code>Checkpoint</code>达到稳定，继续下面的运行。</li>
<li>L1213行对<code>chkpt</code>再次进行了检查。首先，我们需要解释一下<code>instance.chkpts</code>和<code>instance.checkpointStore</code>两个字段的不同。前者存储的是节点自己生成的<code>Checkpoint</code>，后者存储的是接收到的<code>Checkpoint</code>（也包含了自己发送给自己的）。因此，后者是前者的超集。另一方面，即使<code>chkpt</code>对应的<code>Checkpoint</code>已经满足了<code>Stable</code>的要求，其收到的2f+1个<code>Checkpoint</code>可能全部是从别的节点接收到的。也即出现L1213行中判断<code>ok</code>值为<code>false</code>的情况。在此情况下，往往说明当前节点的数据状态落后于其他节点了。 代码在此处做了一个小优化。既然当前节点的数据状态已经落后了，如果当前节点正好处于数据同步的过程中（即L1216行<code>instance.skipInProgress</code>值为<code>true</code>），并且<code>chkpt</code>的<code>SequenceNumber</code>超过了当前<code>Water mark</code>的中位值（即L1220行），那就直接更新<code>Water mark</code>值到这个中位值（即L1222行）。更新<code>Water mark</code>值的目的在于：当当前轮次的状态同步过程结束后，会再次检查<code>Water mark</code>，若<code>Water mark</code>中的<code>low-water mark</code>仍然高于当前更新轮次的<code>seqNo</code>，则开启新一轮的状态同步。这样的优化加速了状态同步的进程。 关于“状态数据的同步”，笔者将在后面专门用一篇博客进行介绍。</li>
<li>代码执行到L1231行的话，说明：<code>chkpt</code>已经达到了稳定条件（即：接收到超过2f+1个<code>Checkpoint</code>消息），并且该节点自己也生成了其对应的<code>Checkpoint</code>。那么，就可以直接更新<code>Water mark</code>了。</li>
<li>L1233行调用<code>processNewView</code>进行<code>View</code>切换相关的处理。关于<code>View</code>切换，笔者在后面也会再写一篇博客进行介绍。</li>
</ol>
<h2 id="iii.-小结">III. 小结</h2>
<p>本篇博客主要介绍了<code>Fabric</code>中的<code>PBFT</code>是如何生成<code>Checkpoint</code>的，以及在达到<code>Stable Checkpoint</code>时，如何更新节点的<code>Water mark</code>。 此外，跟<code>Checkpoint</code>最相关的另一个机制是<code>View</code>的切换，这一点我们将在后面的博客中进行介绍。</p>
<h2 id="参考文献">参考文献</h2>
<ol type="1">
<li><a target="_blank" rel="noopener" href="http://yangzhe.me/2020/01/04/fabric-pbft/">PBFT代码篇：fabric 中的 PBFT 实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jiang_xinxing/article/details/53787071">Hyperledger Fabric的PBFT源码分析（一）</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014633283/article/details/112307024">Fabric中PBFT源码解读 （1）</a></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Blockchain/" rel="tag"># Blockchain</a>
              <a href="/tags/PBFT/" rel="tag"># PBFT</a>
              <a href="/tags/Fabric/" rel="tag"># Fabric</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/13/why-pbft-2f+1/" rel="prev" title="为什么PBFT协议中需要2f+1">
      <i class="fa fa-chevron-left"></i> 为什么PBFT协议中需要2f+1
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/24/fabric-source-code-analysis-7/" rel="next" title="Fabric中PBFT源码解读——状态同步">
      Fabric中PBFT源码解读——状态同步 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#i.-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="nav-number">1.</span> <span class="nav-text">I. 写在前面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a.-%E5%89%8D%E7%BD%AE%E9%98%85%E8%AF%BB"><span class="nav-number">1.1.</span> <span class="nav-text">A. 前置阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b.-%E5%AF%B9testcheckpoint%E5%87%BD%E6%95%B0%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-number">1.2.</span> <span class="nav-text">B. 对TestCheckpoint函数的测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ii.-%E5%AF%B9testcheckpoint%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E8%A7%A3%E8%AF%BB"><span class="nav-number">2.</span> <span class="nav-text">II. 对TestCheckpoint函数运行流程的解读</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a.-checkpoint%E5%92%8Cwater-mark%E7%9A%84%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A"><span class="nav-number">2.1.</span> <span class="nav-text">A. Checkpoint和Water mark的概念解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b.-sendpreprepare%E5%87%BD%E6%95%B0%E4%B8%AD%E5%AF%B9sequence%E7%9A%84%E6%A3%80%E6%9F%A5"><span class="nav-number">2.2.</span> <span class="nav-text">B. sendPrePrepare函数中对sequence的检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c.-commit%E8%AF%B7%E6%B1%82%E6%97%B6%E7%94%9F%E6%88%90checkpoint"><span class="nav-number">2.3.</span> <span class="nav-text">C. Commit请求时生成Checkpoint</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d.-recvcheckpoint%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%821"><span class="nav-number">2.4.</span> <span class="nav-text">D. recvCheckpoint函数的实现细节（1）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#e.-recvcheckpoint%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%822"><span class="nav-number">2.5.</span> <span class="nav-text">E. recvCheckpoint函数的实现细节（2）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iii.-%E5%B0%8F%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">III. 小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-number">4.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Seafooler</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:seafooler@gmail.com" title="E-Mail → mailto:seafooler@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Seafooler</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : ,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>












  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
