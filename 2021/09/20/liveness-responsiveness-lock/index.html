<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-kelp.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-kelp.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-kelp.png">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":{"disqus":{"text":"Load Disqus","order":-1}}},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="在HotStuff的PODC版本论文和Arxiv版本论文中，多次将不同共识协议的活性(liveness)和响应度(responsiveness)进行比较。此外，一些博客和其他相关论文中也有关于liveness问题和responsiveness问题的叙述。其中涉及到两点叙述：   Tendermint中在leader切换的时候需要等待一个最大的网络延迟\(\Delta\)，导致Tendermint无">
<meta property="og:type" content="article">
<meta property="og:title" content="也谈PBFT&#x2F;Tendermint&#x2F;HotStuff中的活性问题、响应度问题和锁定问题">
<meta property="og:url" content="http://example.com/2021/09/20/liveness-responsiveness-lock/index.html">
<meta property="og:site_name" content="Seafooler&#39;s Blog">
<meta property="og:description" content="在HotStuff的PODC版本论文和Arxiv版本论文中，多次将不同共识协议的活性(liveness)和响应度(responsiveness)进行比较。此外，一些博客和其他相关论文中也有关于liveness问题和responsiveness问题的叙述。其中涉及到两点叙述：   Tendermint中在leader切换的时候需要等待一个最大的网络延迟\(\Delta\)，导致Tendermint无">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/liveness-responsiveness-lock/safenode-predicate.png">
<meta property="og:image" content="http://example.com/images/liveness-responsiveness-lock/pseudocode1.png">
<meta property="og:image" content="http://example.com/images/liveness-responsiveness-lock/pseudocode2.png">
<meta property="og:image" content="http://example.com/images/liveness-responsiveness-lock/pseudocode3.png">
<meta property="article:published_time" content="2021-09-19T16:00:00.000Z">
<meta property="article:modified_time" content="2022-01-05T13:49:24.370Z">
<meta property="article:author" content="Seafooler">
<meta property="article:tag" content="Consensus">
<meta property="article:tag" content="PBFT">
<meta property="article:tag" content="Distributed_system">
<meta property="article:tag" content="Theory">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/liveness-responsiveness-lock/safenode-predicate.png">

<link rel="canonical" href="http://example.com/2021/09/20/liveness-responsiveness-lock/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>也谈PBFT/Tendermint/HotStuff中的活性问题、响应度问题和锁定问题 | Seafooler's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Seafooler's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/20/liveness-responsiveness-lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seafooler">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seafooler's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          也谈PBFT/Tendermint/HotStuff中的活性问题、响应度问题和锁定问题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-09-20T00:00:00+08:00">2021-09-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed-theory/" itemprop="url" rel="index"><span itemprop="name">Distributed theory</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在<code>HotStuff</code>的<code>PODC</code>版本<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3293611.3331591">论文</a>和<code>Arxiv</code>版本<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1803.05069">论文</a>中，多次将不同共识协议的活性(<code>liveness</code>)和响应度(<code>responsiveness</code>)进行比较。此外，一些博客和其他相关论文中也有关于<code>liveness</code>问题和<code>responsiveness</code>问题的叙述。其中涉及到两点叙述：</p>
<blockquote>
<ol type="1">
<li><code>Tendermint</code>中在<code>leader</code>切换的时候需要等待一个最大的网络延迟<span class="math inline">\(\Delta\)</span>，导致<code>Tendermint</code>无法做到<code>optimistic responsiveness</code></li>
<li>如果<code>Tendermint</code>在<code>leader</code>切换的时候不等待<span class="math inline">\(\Delta\)</span>，将导致<code>Tendermint</code>中无法进行有效共识，从而破坏协议的<code>liveness</code>。</li>
</ol>
</blockquote>
<p>但笔者在看这两点叙述的时候，总感觉论文作者和博主没有将问题讲透，看得云里雾里的。可能大佬们觉得这两点叙述很容易理解，甚至是一些一点就该通的常识。</p>
<p>为了真正弄懂以上两点叙述，笔者查阅了大量资料，并将自己的一些理解整理在这篇博客中。这篇博客需要读者对共识算法已经有了一定的理解。 <span id="more"></span></p>
<h2 id="i.两三阶段共识中的锁定机制">I.两/三阶段共识中的锁定机制</h2>
<p>我们先从共识协议中的“锁定机制”开始说起。 无论是<code>PBFT</code>、<code>Tendermint</code>还是<code>HotStuff</code>，都在共识过程中隐式或显示地引入了锁定机制。其中，<code>PBFT</code>论文中没有显示定义这种锁定机制，但每个<code>replica</code>在本地<code>prepared</code>之后，就可以认为是在锁定了。 <code>PBFT</code>和<code>Tendermint</code>/<code>HotStuff</code>中锁定的作用是不同的：</p>
<ol type="1">
<li><code>PBFT</code>中的锁定机制只是为了防止一个诚实<code>replica</code>同时对两个矛盾的<code>proposal</code>投票，而不会检查新的<code>proposal</code>是否基于已锁定的<code>proposal</code>。这样的锁定机制也就不对已锁定的<code>proposal</code>做出任何承诺，即：在发生<code>leader</code>切换的时候，上一个<code>view</code>中锁定的<code>proposal</code>在本轮中可以被轻易推翻。</li>
<li>相反，<code>Tendermint</code>/<code>HotStuff</code>中的锁定机制除了防止一个诚实<code>replica</code>对两个矛盾<code>proposal</code>投票外，还会进一步检查新的<code>proposal</code>是否基于已锁定的<code>proposal</code>。这样的锁定机制对于已锁定的<code>proposal</code>做出了一定的承诺，即：在上一个<code>view</code>中已经被锁定的<code>proposal</code>，除非发生特殊情况（<code>replica</code>接收到的<code>proposal</code>基于更高的<code>QC</code>），在新的<code>view</code>中不会被推翻。</li>
</ol>
<p>这两种锁定机制的不同源于他们对于<code>leader</code>赋予的可信度是不同的。</p>
<h2 id="ii.共识协议中leader可信度的不同">II.共识协议中Leader可信度的不同</h2>
<p><code>PBFT</code>中<code>leader</code>的可信度是很大的（其作恶空间很小），这是因为<code>leader</code>在进行<code>View</code>的切换时，其在发出的<code>New-View</code>消息中携带了充分的证明性数据，其他<code>replica</code>有理由相信<code>leader</code>在<code>New-View</code>消息中是很难作恶的。所以大家都把本地锁定的数据修改为<code>leader</code>发来的<code>New-View</code>中携带的数据。 这也导致了<code>HotStuff</code>等论文中诟病的<code>PBFT</code>进行<code>View</code>切换时的高开销问题，因为<code>New-View</code>消息中需要携带证明性数据。</p>
<p>相反，<code>Tendermint</code>/<code>HotStuff</code>中的<code>leader</code>在进行<code>view</code>切换时，无需携带证明性数据。因此，<code>leader</code>的可信度较低（作恶空间很大）。对于<code>leader</code>发来的新的<code>proposal</code>，其他<code>replica</code>需要对其进行更为严格的检查，也即出现了在上一节中所述的：<code>Tendermint</code>/<code>HotStuff</code>中的锁定机制要求进一步检查新的<code>proposal</code>是否基于已锁定的<code>proposal</code>。</p>
<p>接下来，我们继续对<code>Tendermint</code>/<code>HotStuff</code>类的锁定机制的设计进行分析，并将这一类共识简称为“<code>single-modal</code>”类共识（<code>PBFT</code>被称为<code>bi-modal</code>类共识）</p>
<h2 id="iii.single-modal类共识中锁定机制的设计">III.Single-modal类共识中锁定机制的设计</h2>
<p>在第I节中，我们介绍到：<code>Single-modal</code>类共识在检查新的<code>proposal</code>时，会进一步检查该<code>proposal</code>是否基于其本地已经锁定的<code>proposal</code>（或者说<code>QC</code>）。如果新<code>proposal</code>不是基于锁定的<code>QC</code>，那么这个<code>replica</code>会拒绝对该<code>proposal</code>投票。 同时，我们也补充说明了另外一种情况：如果新的<code>proposal</code>所指向（基于）的<code>QC</code>高于<code>replica</code>本地锁定的<code>QC</code>，该<code>replica</code>会将自己锁定的<code>QC</code>更新到<code>proposal</code>所基于的<code>QC</code>，并对其进行投票。 为了方便讨论，我们对这两种投票的情况分别命名为规则1和规则2。这两条规则也对应于<code>HotStuff</code><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/3293611.3331591">论文</a>中的<code>SAFENODE</code>原语的设计，如下所示： <!-- ![SAFENODE原语](https://img-blog.csdnimg.cn/a7e8bf518bf848d193e48932c7e13432.png) --> <img src="/images/liveness-responsiveness-lock/safenode-predicate.png" height=80 /> 关于规则1，前面也讨论了，是为了减小<code>leader</code>的作恶空间，从而保证安全性；关于规则2，论文中写到是为了保证活性（<code>liveness</code>）。我们来看看这一点如何理解。</p>
<h3 id="a.-对锁定机制中规则2活性的理解">A. 对锁定机制中规则2活性的理解</h3>
<p>我们假想一下，如果没有规则2，<code>Single-modal</code>类共识会出现什么样的问题。没有规则2，也就意味着：每个<code>replica</code>都只会对基于自己的<code>QC</code>的<code>proposal</code>投票。 我们考虑如下一个例子：</p>
<blockquote>
<ol start="0" type="1">
<li>假设在<code>view 0</code>的时候，<code>replica 0</code>是<code>leader</code>，且只有其收到了<code>QC</code>并在本地锁定了<code>v0</code>，此时由于网络原因发生了<code>view</code>的切换.</li>
<li>在<code>view 1</code>的时候，新的<code>leader</code> (<code>replica 1</code>)由于没有在<code>v0</code>锁定，于是基于更早的一个<code>view</code>（假设是<code>vold</code>）发起了<code>proposal</code>；此时<code>replica 0</code>是不会进行投票的，因为这个<code>proposal</code>不是基于<code>v0</code>的，但其他的节点还是可能会投票，当<code>replica 1</code>收到了足够多的投票组成<code>QC</code>后，其在本地锁定<code>v1</code>；此时也由于网络原因发生了<code>view</code>的切换。</li>
<li>在<code>view 2</code>的时候，同理，<code>replica 2</code>锁定了<code>v2</code>。 ...</li>
<li>在<code>view f</code>的时候，<code>replica f</code>锁定了<code>vf</code>。</li>
<li>此时，<code>replica (2f+1)</code> ~ <code>replica (3f)</code>下线了，只剩下<code>replica 0</code> ~ <code>replica 2f</code>。（这也是满足系统假设的，有超过<code>2f+1</code>个正确节点，并且我们假设接下来是<strong>同步网络</strong>）</li>
<li>但接下来，协议就会卡住。</li>
<li>在新一轮次（所有<code>replica</code>轮一遍称为一个轮次）的<code>view</code>中，<code>replica 0</code>发起的新<code>proposal</code>，<code>replica 1</code> ~ <code>replica f</code>都不认，因为不是基于他们锁定的<code>view</code>发起的，从而无法收集到新的<code>QC</code>；</li>
<li>同理，<code>replica 1</code>发起的新<code>proposal</code>，<code>replica 0</code>，<code>replica 2</code> ~ <code>replica f</code>都不认，因为不是基于他们锁定的<code>view</code>发起的，从而无法收集到新的<code>QC</code>； ...</li>
</ol>
</blockquote>
<p>上面这个例子在第4步之后，<code>replica 0</code> ~ <code>replia f</code>都不会给除了自己之外的其他节点的<code>proposal</code>投票。在每个<code>view</code>中<code>leader</code>无法都无法收集到<code>2f+1</code>个投票，也无法生成/锁定新的<code>QC</code>。 因此，整个协议就卡住了。</p>
<p>也就是说，在没有规则2的情况下，<code>Single-modal</code>类共识会卡住，从而失去活性。</p>
<p>相反，当引入规则2后，我们看看上面的例子会怎么变化：</p>
<blockquote>
<ol start="0" type="1">
<li>假设在<code>view 0</code>的时候，<code>replica 0</code>是<code>leader</code>，且只有其收到了<code>QC</code>并在本地锁定了<code>v0</code>，此时由于网络原因发生了<code>view</code>的切换.</li>
<li>在<code>view 1</code>的时候，新的<code>leader</code> (<code>replica 1</code>)由于没有在v0锁定，于是基于更早的一个<code>view</code>（假设是<code>vold</code>）发起了<code>proposal</code>；此时<code>replica 0</code>是不会进行投票的，因为这个<code>proposal</code>不是基于<code>v0</code>的，但其他的节点还是可能会投票，当<code>replica 1</code>收到了足够多的投票组成<code>QC</code>后，其在本地锁定<code>v1</code>；此时也由于网络原因发生了<code>view</code>的切换。</li>
<li>在<code>view 2</code>的时候，同理，<code>replica 2</code>锁定了<code>v2</code>。 ...</li>
<li>在<code>view f</code>的时候，<code>replica f</code>锁定了<code>vf</code>。</li>
<li>此时，<code>replica (2f+1)</code> ~ <code>replica (3f)</code>下线了，只剩下<code>replica 0</code> ~ <code>replica 2f</code>。（这也是满足系统假设的，有超过<code>2f+1</code>个正确节点，并且我们假设接下来是<strong>同步网络</strong>）</li>
</ol>
<p>---------- 上面和前一个例子一样，下面是规则2引入后的不同</p>
<ol start="5" type="1">
<li>在新一轮的<code>view</code>中，虽然<code>replica 0</code> ~ <code>replica f-1</code>发起的新<code>proposal</code>，都无法得到其他所有节点的认可，从而无法收集到新的<code>QC</code>；但当轮转到<code>replica f</code>的时候，其基于<code>view f</code>发起新的<code>proposal</code>能够得到所有<code>replica</code>的认可，从而对其投票，因而<code>replica f</code>可以收集到足够多的投票并生成<code>QC</code>。 这就从上面例子中“协议卡住”的情况解脱出来了。</li>
</ol>
</blockquote>
<p>这里，我们可能会有一个想法</p>
<blockquote>
<p>每一个轮次，前面的<code>replica 0</code> ~ <code>replica f-1</code>发起的<code>proposal</code>都无法得到其他所有节点的投票，只有等到<code>replica f</code>的时候，才真正收集到足够多的投票形成<code>QC</code>，不会效率太低了嘛？</p>
</blockquote>
<p>针对该问题，<code>Single-modal</code>类共识都做了一个优化设计：</p>
<blockquote>
<p>在每个<code>replica</code>发起新的<code>proposal</code>之前，允许其收集其他<code>replica</code>中的锁定的<code>QC</code>信息，再基于收集到的最高的<code>QC</code>发起新的<code>proposal</code>，就可以大大提升效率了。</p>
</blockquote>
<p>举例来说，在上个例子中，如果<code>replica 0</code>在发起<code>proposal</code>之前就收到了<code>replica f</code>发来的<code>QC</code>（锁定在<code>vf</code>高度），其基于该<code>QC</code>发起新的<code>proposal</code>，就可以得到其他所有<code>replica</code>的认可了。</p>
<h3 id="b.-为什么tendermint在进行leader切换的时候要等待delta">B. 为什么<code>Tendermint</code>在进行<code>leader</code>切换的时候要等待<span class="math inline">\(\Delta\)</span></h3>
<p>一切似乎都很美好了。但<code>Tendermint</code>在进行<code>leader</code>切换的时候，要求<code>leader</code>在发起<code>proposal</code>之前等待一个网络时延的上限<span class="math inline">\(\Delta\)</span>。这使得<code>Tendermint</code>无法实现<code>optimistic responsiveness</code>。 我们先来分析一下为什么要等待<span class="math inline">\(\Delta\)</span>。</p>
<h4 id="tendermint不等待delta导致的hidden-lock问题">1. <code>Tendermint</code>不等待<span class="math inline">\(\Delta\)</span>导致的<code>Hidden Lock</code>问题</h4>
<p><code>Hidden lock</code>考虑的是同步网络下的问题，因为异步网络比同步网络更难解决。如果同步网络中存在<code>Hidden lock</code>问题，异步网络中也会存在类似且更复杂的问题。 以下，我们考虑同步网络下的<code>Hidden lock</code>问题。为了解释该问题，我们也举个例子如下。该例子中一开始是异步网络，后面切换到同步网络。</p>
<blockquote>
<ol start="0" type="1">
<li>假设一开始所有<code>replica</code>都是锁定在一个<code>view</code> (<code>vold</code>)的<code>QC</code>上。 接下来，在<code>view 0</code>的时候，<code>replica 0</code>是<code>leader</code>，其首先收集<code>2f</code>个其他<code>replica</code>发来的<code>QC</code>（加上自身的<code>QC</code>一共<code>2f+1</code>个），这<code>2f+1</code>个<code>QC</code>中的最大值是<code>vold</code>的<code>QC</code>；<code>replica 0</code>基于该<code>QC</code>发起了<code>proposal</code>；其他<code>replica</code>对该<code>proposal</code>纷纷进行投票；<code>replica 0</code>收集到<code>2f+1</code>个投票后组成<code>QC</code>，并在本地锁定了<code>v0</code>；此时，由于网络原因发生<code>view</code>的切换，使得除了<code>replica 0</code>之外其他的节点都没有收到<code>v0</code>对应的<code>QC</code>；</li>
<li>在<code>view 1</code>的时候，<code>replica 1</code>是<code>leader</code>，其首先收集<code>2f</code>个其他<code>replica</code>发来的<code>QC</code>（加上自身的<code>QC</code>一共<code>2f+1</code>个），这<code>2f+1</code>个<code>QC</code>中的最大值是<code>vold</code>的<code>QC</code>（也即其未收到<code>replica 0</code>发来的<code>QC</code>）；<code>replica 1</code>基于该<code>QC</code>发起了<code>proposal</code>；除了<code>replica 0</code>之外的其他<code>replica</code>对该<code>proposal</code>纷纷进行投票；<code>replica 1</code>收集到<code>2f+1</code>个投票后组成<code>QC</code>，并在本地锁定了<code>v1</code>；此时，由于网络原因发生<code>view</code>的切换，使得除了<code>replica 1</code>之外其他的节点都没有收到<code>v1</code>对应的<code>QC</code>；</li>
<li>同理，在<code>view 2</code>的时候，只有<code>replica 2</code>在本地锁定了<code>v2</code>对应的<code>QC</code>，其他<code>replica</code>都未收到； ...</li>
<li>在<code>view f</code>的时候，只有<code>replica f</code>在本地锁定了<code>vf</code>对应的<code>QC</code>，其他<code>replica</code>都未收到；</li>
<li>在<code>view (f+1)</code>的时候，<code>replica (f+1)</code>发起<code>proposal</code>，但<code>replica 0</code> ~ <code>replica f</code>都不会进行投票。这一轮的<code>view</code>不会生成任何<code>QC</code> ...</li>
<li>在<code>view (3f)</code>的时候，<code>replica (3f)</code>发起<code>proposal</code>，但<code>replica 0</code> ~ <code>replica f</code>都不会进行投票。这一轮的<code>view</code>不会生成任何<code>QC</code></li>
</ol>
<p>-----------以上是异步网络环境，接下来进入同步网络环境。在该网络环境中，除了拜占庭节点，所有的节点之间的消息在<span class="math inline">\(\Delta\)</span>时间内都能正确送达------------</p>
<ol start="6" type="1">
<li>在<code>view (3f+1)</code>的时候，又回到<code>replica 0</code>，其首先收集了<code>2f</code>个其他<code>replica</code>发来的<code>QC</code>（加上自身的<code>QC</code>一共<code>2f+1</code>个），但巧合（也可能是恶意节点对网络的操纵）的是这<code>2f+1</code>个<code>QC</code>中的最大值是<code>replica 0</code>自身的<code>QC</code>，也即锁定在<code>v0</code>上的<code>QC</code>（这种情况下，<code>replica 0</code>收到的前<code>2f</code>个<code>QC</code>中没有来自<code>replica 1</code>~<code>replica f</code>节点的）。于是，其基于<code>v0</code>发起新的<code>proposal</code>，但<code>replica 1</code> ~ <code>replica f</code>都不会投票，<code>replica (f+1)</code>~ <code>replica (3f)</code>中的拜占庭节点也全不投票（假设其中有k个拜占庭节点），导致<code>replica 0</code>只能收到<code>(2f+1-k)</code>个投票（包含自身的），无法组成<code>QC</code>。其他诚实节点由于无法及时收到<code>QC</code>将<code>view</code>切换到 <code>3f+2</code>。此时，拜占庭节点进行投票，使得<code>replica 0</code>又收到了足够多的投票，组建出<code>QC</code>。于是，<strong><code>replica 0</code>锁定了<code>v (3f+1)</code></strong>。但其他节点已经切换到<code>view (3f+2)</code>了，即使接收到<code>replica 0</code>发来的<code>QC</code>，也不会更新自己本地锁定的<code>QC</code>了。</li>
<li>在<code>view (3f+2)</code>的时候，又回到<code>replica 1</code>，其首先收集了<code>2f</code>个其他<code>replica</code>发来的<code>QC</code>（加上自身的<code>QC</code>一共<code>2f+1</code>个），但巧合（也可能是恶意节点对网络的操纵）的是这<code>2f+1</code>个<code>QC</code>中的最大值是<code>replica 1</code>自身的<code>QC</code>，也即锁定在<code>v1</code>上的<code>QC</code>。于是，其基于<code>v1</code>发起新的<code>proposal</code>，但<code>replica 0</code>和 <code>replica2</code> ~ <code>replica f</code>都不会投票，<code>replica (f+1)</code> ~ <code>replica (3f)</code>中的拜占庭节点也全不投票（假设其中有<code>k</code>个拜占庭节点），导致<code>replica 1</code>只能收到<code>(2f+1-k)</code>个投票（包含自身的），无法组成<code>QC</code>。其他诚实节点由于无法及时收到<code>QC</code>将<code>view</code>切换到 <code>3f+3</code>。此时，拜占庭节点进行投票，使得<code>replica 1</code>又收到了足够多的投票，组建出<code>QC</code>。于是，<strong><code>replica 1</code>锁定了<code>v (3f+2)</code></strong>。 ...</li>
<li>在<code>view (3f+f+1)</code>的时候，又回到<code>replica f</code>，同理，<strong>只有<code>replica f</code>锁定了<code>v (3f+f+1)</code></strong>。</li>
<li>在<code>view (3f+f+2)</code>的时候，又回到<code>replica (f+1)</code>，其首先收集了<code>2f</code>个其他<code>replica</code>发来的<code>QC</code>（加上自身的<code>QC</code>一共<code>2f+1</code>个），但巧合（也可能是恶意节点对网络的操纵）的是这<code>2f+1</code>个<code>QC</code>中的最大值是<code>replica 0</code>发来的<code>QC</code>，即锁定在<code>v (3f+1)</code>上。于是，其基于<code>v (3f+1)</code>发起新的<code>proposal</code>，但<code>replica 1</code> ~ <code>replica f</code>都不会投票，<code>replica (f+1)</code>~ <code>replica (3f)</code>中的拜占庭节点也全不投票（假设其中有<code>k</code>个拜占庭节点），导致<code>replica (f+1)</code>只能收到<code>(2f+1-k)</code>个投票（包含自身的），<strong>无法组成<code>QC</code></strong>。其他诚实节点由于无法及时收到<code>QC</code>将<code>view</code>切换到 <code>3f+f+3</code>。 ...</li>
<li>在<code>view (3f+3f+1)</code>的时候，又回到<code>replica (3f)</code>，其同样<strong>无法组成<code>QC</code></strong>。其他诚实节点由于无法及时收到<code>QC</code>将<code>view</code>切换到<code>3f+3f+2</code>。</li>
<li>在<code>view (3f+3f+2)</code>的时候，又回到<code>replica 0</code>，其又回到步骤6 ...</li>
</ol>
</blockquote>
<p>上面的例子可能叙述得比较复杂，简单来说就是：在每个轮次中，前<code>f+1</code>个<code>view</code>中有且只有<code>leader</code>对应得<code>replica</code>锁定到当前<code>view</code>上，后<code>2f</code>个<code>view</code>中所有<code>replica</code>都无法更新锁定的<code>view</code>。这两点又是分别通过以下的思路来实现的： 1. 前<code>f+1</code>个<code>view</code>中，在<code>leader</code>收集<code>QC</code>的时候，<strong>只收集到自身的<code>QC</code>和后<code>2f</code>个<code>replica</code>的<code>QC</code></strong>，导致这<code>2f+1</code>个<code>QC</code>中的<strong>最大值是<code>leader</code>自身的<code>QC</code></strong>，<code>leader</code>基于该<code>QC</code>发起新的<code>proposal</code>；对于发起的<code>proposal</code>，前<code>f+1</code>个<code>replica</code>中除了自身之外都不会投票；<strong>后<code>2f</code>个<code>replica</code>中所有拜占庭节点一开始也不投票</strong>，导致<code>leader</code>收集不到足够的投票，触发其他诚实节点超时切换到下一个<code>view</code>；<strong>然后，拜占庭节点进行投票</strong>，使得<code>leader</code>收集到足够多的投票，生成更新的<code>QC</code>，该<code>QC</code>比前<code>f+1</code>个<code>replica</code>中的其他<code>replica</code>中的<code>QC</code>都要大。 2. 在后<code>2f</code>个<code>view</code>中，在<code>leader</code>收集<code>QC</code>的时候，<strong>除了收集到的后<code>2f</code>个<code>replica</code>中发来的<code>QC</code>，也会收集到前<code>f+1</code>个<code>replica</code>中的某一个<code>QC</code></strong>，我们假设其只能收集到最低的那个<code>QC</code>；<code>leader</code>基于该<code>QC</code>发起新的<code>proposal</code>；对于发起的<code>proposal</code>，前<code>f+1</code>个<code>replica</code>只有一个会进行投票；<strong>后<code>2f</code>个<code>replica</code>中所哟有拜占庭节点一直不投票</strong>，导致<code>leader</code>一直收集不到足够多的投票，从而无法生成更新的<code>QC</code>，其他诚实节点也被触发超时切换到下一个<code>view</code>。</p>
<p>这里需要引入<code>Single-modal</code>类共识有效运行的定义：只有发生了两连跳才算是真正完成了一次有效（为什么要求这一点，我们在后面的博客进行详细解释，这里先记住这个结论）。也即：在<code>view k</code>，必须是基于<code>view (k-1)</code>中锁定的<code>QC</code>发起<code>proposal</code>。</p>
<p>而上面举的例子显然无法完成任何共识，因为整个协议在运行过程中不存在两连跳。这个问题也被称为<code>hidden lock</code>问题。</p>
<h4 id="为什么等待delta可以解决hidden-lock问题">2. 为什么等待<span class="math inline">\(\Delta\)</span>可以解决<code>Hidden Lock</code>问题</h4>
<p>造成<code>hidden lock</code>问题的根本原因是，一个<code>leader</code>在发起新的<code>proposal</code>之前并没有等待其他所有诚实节点发来的<code>QC</code>，从而从中选出最高的<code>QC</code>。也即：有些诚实节点中的<code>QC</code>被隐藏 (hidden)了。 反过来说，如果我们要求每个<code>leader</code>在发起新的<code>proposal</code>之前必须等待同步网络中的一个最大网络时延，使得其能接收到所有诚实节点发来的<code>QC</code>，那么在上面的例子中：<code>replica 1</code>中就可以基于<code>replica 0</code>中刚刚更新的<code>QC</code>发起<code>proposal</code>。该<code>QC</code>是网络中最高的<code>QC</code>，一定可以得到其他所有诚实节点的投票，从而在<code>replica 1</code>中生成<code>QC</code>。这样，就保证了<code>replica 1</code>和<code>replica 0</code>中分别生成的两个<code>QC</code>是两连跳的。</p>
<h3 id="c.-为什么hotstuff不需要等待delta">C. 为什么<code>HotStuff</code>不需要等待<span class="math inline">\(\Delta\)</span></h3>
<p><code>HotStuff</code>增加了一个轮次。其中第一个轮次后的<code>QC</code>称为<code>prepareQC</code>，第二个轮次后的<code>QC</code>称为<code>lockedQC</code>。 <code>Leader</code>在发起新的<code>proposal</code>时将基于收集到的最高的<code>prepareQC</code>进行，而<code>replica</code>投票时将基于<code>proposal</code>中携带的最高<code>prepareQC</code>和本地保存的<code>lockedQC</code>作比较。 对于任意一个<code>lockedQC</code>而言，其至少在<code>2f+1</code>个节点中保存有对应的<code>prepareQC</code>，这进一步保证了<code>leader</code>在发起新的<code>proposal</code>时至少收集到一个该<code>prepareQC</code>。 因此，对于所有节点中保存的最高的<code>lockedQC</code>，<code>leader</code>一定会接收到其对应的<code>prepareQC</code>，从而基于该<code>prepareQC</code>发起<code>proposal</code>，也一定会被所有诚实节点投票。</p>
<p>总结来说，<code>HotStuff</code>通过增加一个阶段，保证了<code>leader</code>一定可以搜集到最高<code>lockedQC</code>对应的<code>prepareQC</code>。 因而，<code>HotStuff</code>不需要等待<span class="math inline">\(\Delta\)</span>。</p>
<h2 id="iv.-一个问题replica接收到旧view中的消息如何处理">IV. 一个问题：<code>replica</code>接收到旧<code>view</code>中的消息如何处理</h2>
<p>在III.B.1小节中，我们举了个例子来说明<code>hidden lock</code>问题。其中，我们假设：当<code>replica</code>切换到下一个<code>view</code>后，即使其再接收到上一个<code>view</code>中的<code>QC</code>，也不会更新自己本地锁定的<code>QC</code>。这样的假设源于我们对于<code>HotStuff</code>论文中伪代码的解读，而且可以简化III.B.1小节中的例子。 但笔者在在思考另外一种假设的合理性：<code>replica</code>接收并认可上一个<code>view</code>中的<code>QC</code>貌似也是合情合理的，而且可以让协议更加鲁棒。在本节，我们就对两种假设进行更深入的讨论。</p>
<h3 id="a.-假设一认为旧view中的消息是无效的">A. 假设一：认为旧<code>view</code>中的消息是无效的</h3>
<p>这一种假设在<code>HotStuff</code>论文中的<code>Algorithm 2</code> (<code>Basic HotStuff</code>)和<code>Algorithm 3</code>(<code>Chained HotStuff</code>)都是明确指明的，相应的伪代码分别截图如下： <!-- ![Algorithm 2在更新prepareQC前的MATCHINGQC调用](https://img-blog.csdnimg.cn/628a237573c44e59ab5ab538b1b30e7a.png) --> <img src="/images/liveness-responsiveness-lock/pseudocode1.png" height=120 /> <!-- ![Algorithm 2在更新lockedQC前的MATCHINGQC调用](https://img-blog.csdnimg.cn/375b9ceb84374f5e9d9d79036480078a.png) --> <img src="/images/liveness-responsiveness-lock/pseudocode2.png" height=115 /> <!-- ![Algorithm 3在更新genericQC和lockedQC前对MATCHINGMSG的调用](https://img-blog.csdnimg.cn/474cce66ccb24b19a0018472c196cd79.png) --> <img src="/images/liveness-responsiveness-lock/pseudocode3.png" height=95 /> 这三处伪代码中，<code>replica</code>在收到来自<code>leader</code>的消息后，都会调用<code>MATCHINGQC</code>或<code>MATCHINGMSG</code>对消息进行检查，其中就包括消息中包含的<code>viewNumber</code>是否等于<code>curView</code>。也即：当<code>replica</code>已经切换到下一个<code>view</code>后，即使其再接收到上一个<code>view</code>中的消息，也会直接丢弃。</p>
<p>但另一方面，在<code>HotStuff</code>论文的<code>Algorithm 4</code>（<code>Event-driven HotStuff</code>）中，并没有对接收到的消息的<code>viewNumber</code>进行明确检查。这一点需要阅读<code>HotStuff</code>源码后进行进一步确认。</p>
<h3 id="b.-假设二认为旧view中的消息有效的">B. 假设二：认为旧<code>view</code>中的消息有效的</h3>
<p><code>Tendermint</code><a target="_blank" rel="noopener" href="https://atrium.lib.uoguelph.ca/xmlui/handle/10214/9769">论文</a>对是否进行<code>viewNumber</code>检查也没有进行明确说明。我们暂且不考虑<code>Tendermint</code>以及<code>HotStuff</code>中<code>Algorithm 4</code>的设计，来推演一下：如果认可旧<code>view</code>中的消息，<code>Single-modal</code>类的二阶段共识会存在什么问题。</p>
<p>基于该假设，我们需要对III.B.1小节中构造的例子进行更新，更新后的例子如下：</p>
<blockquote>
<ol start="0" type="1">
<li>假设一开始所有<code>replica</code>都是锁定在一个<code>view</code> (<code>vold</code>)的QC上 接下来，在<code>view 0</code>的时候，<code>replica 0</code>是<code>leader</code>，其首先收集<code>2f</code>个其他<code>replica</code>发来的<code>QC</code>（加上自身的<code>QC</code>一共<code>2f+1</code>个），这<code>2f+1</code>个<code>QC</code>中的最大值是<code>vold</code>的<code>QC</code>；<code>replica 0</code>基于该<code>QC</code>发起了<code>proposal</code>；其他<code>replica</code>对该<code>proposal</code>纷纷进行投票；<code>replica 0</code>收集到<code>2f+1</code>个投票后组成<code>QC</code>，并在本地锁定了<code>v0</code>；此时，由于网络原因发生<code>view</code>的切换，使得除了<code>replica 0</code>之外其他的节点都没有收到<code>v0</code>对应的<code>QC</code>；</li>
<li>在<code>view 1</code>的时候，<code>replica 1</code>是<code>leader</code>，其首先收集<code>2f</code>个其他<code>replica</code>发来的<code>QC</code>（加上自身的<code>QC</code>一共<code>2f+1</code>个），这<code>2f+1</code>个<code>QC</code>中的最大值是<code>vold</code>的<code>QC</code>（也即其未收到<code>replica 0</code>发来的<code>QC</code>）；<code>replica 1</code>基于该<code>QC</code>发起了<code>proposal</code>；除了<code>replica 0</code>之外的其他<code>replica</code>对该<code>proposal</code>纷纷进行投票；<code>replica 1</code>收集到<code>2f+1</code>个投票后组成<code>QC</code>，并在本地锁定了<code>v1</code>；此时，由于网络原因发生<code>view</code>的切换，使得除了<code>replica 1</code>之外其他的节点都没有收到<code>v1</code>对应的<code>QC</code>；</li>
<li>同理，在<code>view 2</code>的时候，只有<code>replica 2</code>在本地锁定了<code>v2</code>对应的<code>QC</code>，其他<code>replica</code>都未收到； ...</li>
<li>在<code>view f</code>的时候，只有<code>replica f</code>在本地锁定了<code>vf</code>对应的<code>QC</code>，其他<code>replica</code>都未收到；</li>
<li>在<code>view (f+1)</code>的时候，<code>replica (f+1)</code>发起<code>proposal</code>，但<code>replica 0</code> ~ <code>replica f</code>都不会进行投票。这一轮的<code>view</code>不会生成任何<code>QC</code> ...</li>
<li>在<code>view (3f)</code>的时候，<code>replica (3f)</code>发起<code>proposal</code>，但<code>replica 0</code> ~ <code>replica f</code>都不会进行投票。这一轮的<code>view</code>不会生成任何<code>QC</code></li>
</ol>
<p>-----------以上是异步网络环境，接下来进入同步网络环境。在该网络环境中，除了拜占庭节点，所有的节点之间的消息在<span class="math inline">\(\Delta\)</span>时间内都能正确送达------------</p>
<ol start="6" type="1">
<li>在<code>view (3f+1)</code>的时候，又回到<code>replica 0</code>，其首先收集了<code>2f</code>个其他<code>replica</code>发来的<code>QC</code>（加上自身的<code>QC</code>一共<code>2f+1</code>个），但巧合（也可能是恶意节点对网络的操纵）的是这<code>2f+1</code>个<code>QC</code>中的最大值是<code>replica 0</code>自身的<code>QC</code>，也即锁定在<code>v0</code>上的<code>QC</code>（这种情况下，<code>replica 0</code>收到的前<code>2f</code>个<code>QC</code>中没有来自<code>replica 1</code>~<code>replica f</code>节点的）。于是，其基于<code>v0</code>发起新的<code>proposal</code>，但<code>replica 1</code> ~ <code>replica f</code>都不会投票，<code>replica (f+1)</code>~ <code>replica (3f)</code>中的拜占庭节点也全不投票（假设其中有<code>k</code>个拜占庭节点），导致<code>replica 0</code>只能收到<code>(2f+1-k)</code>个投票（包含自身的），无法组成<code>QC</code>。其他诚实节点由于无法及时收到<code>QC</code>将<code>view</code>切换到 <code>3f+2</code>，<strong>并将一个旧的<code>QC</code>（低于<code>3f+1</code>）发送给下一任<code>leader</code> (<code>replica 1</code>)</strong>。</li>
<li>在<code>view (3f+2)</code>的时候，又回到<code>replica 1</code>，其首先收集了<code>2f</code>个其他<code>replica</code>发来的<code>QC</code>（加上自身的<code>QC</code>一共<code>2f+1</code>个），这<code>2f+1</code>个<code>QC</code>中的最大值是<code>replica f</code>中的<code>QC</code>，也即锁定在<code>vf</code>上的<code>QC</code>。于是，其基于<code>vf</code>发起新的<code>proposal</code>。与此同时，拜占庭节点向<code>replica 0</code>发送<code>view (3f+1)</code>的投票，使得<code>replica 0</code>又收到了针对<code>view (3f+1)</code>的足够多的投票，组建出<code>v (3f+1)</code>的<code>QC</code>，并进一步将这个<code>QC</code>广播给其他节点。当诚实的<code>replica</code>（<code>replica 0</code> ~ <code>replica 2f</code>）接收到<code>replica 1</code>的<code>proposal</code>后，除了<code>replica 0</code>，其他的<code>replica</code>都会进行投票（尚未收到<code>v (3f+1)</code>的<code>QC</code>），所有的拜占庭节点(<code>replica 2f+1</code>~ <code>replica 3f</code>)也都不投票。导致，<code>replica 1</code>只能收到<code>2f</code>个投票（包含自身的），无法组成<code>QC</code>。其他诚实节点由于无法及时收到<code>QC</code>将<code>view</code>切换到 <code>3f+3</code>。此时，所有诚实节点都接收到了<code>v (3f+1)</code>的<code>QC</code>，因而在进行<code>view</code>切换时，将<code>v (3f+1)</code>的<code>QC</code>发送给下一任<code>leader</code> (<code>replica 2</code>)。</li>
<li>在<code>view (3f+3)</code>的时候，又回到<code>replica 2</code>，其首先收集了<code>2f</code>个其他<code>replica</code>发来的<code>QC</code>（加上自身的<code>QC</code>一共<code>2f+1</code>个），这<code>2f+1</code>个<code>QC</code>中的最大值是锁定在<code>v (3f+1)</code>上的<code>QC</code>。于是，其基于<code>v (3f+1)</code>发起新的<code>proposal</code>。与此同时，拜占庭节点向<code>replica 1</code>发送<code>view (3f+2)</code>的投票，使得<code>replica 1</code>又收到了针对<code>view (3f+2)</code>的足够多的投票，组建出<code>v (3f+2)</code>的<code>QC</code>，并进一步将这个<code>QC</code>广播给其他节点。当诚实的<code>replica</code>（<code>replica 0</code> ~ <code>replica 2f</code>）接收到<code>replica 2</code>的<code>proposal</code>后，除了replica 1，其他的replica都会进行投票（尚未收到<code>v (3f+2)</code>的<code>QC</code>），所有的拜占庭节点(<code>replica 2f+1</code>~<code>replica 3f</code>)也都不投票。导致，<code>replica 2</code>只能收到<code>2f</code>个投票（包含自身的），无法组成<code>QC</code>。其他诚实节点由于无法及时收到<code>QC</code>将<code>view</code>切换到 <code>3f+4</code>。此时，所有诚实节点都接收到了<code>v (3f+2)</code>的<code>QC</code>，因而在进行<code>view</code>切换时，将<code>v (3f+2)</code>的<code>QC</code>发送给下一任<code>leader</code> (<code>replica 3</code>)。 ...</li>
<li>同理，在<code>view (3f+2f+1)</code>的时候，又回到了<code>replica (2f)</code>，其基于 <code>v (3f+2f-1)</code>的<code>QC</code>发起新的<code>proposal</code>；与此同时，拜占庭节点对<code>view (3f+2f)</code>进行投票，使得<code>replica (2f-1)</code>组建成<code>v (3f+2f)</code>的<code>QC</code>，并广播给其他节点。其他节点接收到<code>replica (2f)</code>的<code>proposal</code>后，<code>replica 0</code>~<code>replica (2f-2)</code>会进行投票，<code>replica (2f-1)</code>和所有拜占庭节点都不投票，导致<code>replica (2f)</code>只能收到<code>2f</code>个投票（包含自身的），无法组成<code>QC</code>。其他诚实节点由于无法及时收到<code>QC</code>将<code>view</code>切换到 <code>3f+2f+2</code>。此时，所有诚实节点都接收到了<code>v (3f+2f)</code>的<code>QC</code>，因而在进行<code>view</code>切换时，将<code>v (3f+2f)</code>的<code>QC</code>发送给下一任<code>leader</code> (<code>replica 2f+1</code>)。</li>
<li><code>replica (2f+1)</code> ~ <code>replica (3f)</code>都是拜占庭节点，直接跳过<code>view (3f+2f+2)</code>~<code>view( 3f+3f+1)</code></li>
<li>在<code>view (3f+3f+2)</code>的时候，又回到<code>replica 0</code>，其基于 <code>v (3f+2f)</code>的<code>QC</code>发起新的<code>proposal</code>；与此同时，拜占庭节点对<code>view (3f+2f+1)</code>进行投票，使得<code>replica (2f)</code>组建成<code>v (3f+2f+1)</code>的<code>QC</code>，并广播给其他节点。其他节点接收到<code>replica 0</code>的<code>proposal</code>后，<code>replica 1</code>~<code>replica (2f-1)</code>会进行投票，<code>replica (2f)</code>和所有拜占庭节点都不投票，导致<code>replica 0</code>只能收到<code>2f</code>个投票（包含自身的），无法组成<code>QC</code>。其他诚实节点由于无法及时收到<code>QC</code>将<code>view</code>切换到 <code>3f+3f+3</code>。此时，所有诚实节点都接收到了<code>v (3f+2f+1)</code>的<code>QC</code>，因而在进行<code>view</code>切换时，将<code>v (3f+2f+1)</code>的<code>QC</code>发送给下一任<code>leader</code> (<code>replica 1</code>)。 ...</li>
</ol>
</blockquote>
<p>以上的例子同样暴露了一个问题，就是不存在两连跳的<code>QC</code>，举例来说：<code>v (3f+3)</code>的<code>QC</code>是基于<code>v (3f+1)</code>的<code>QC</code>，而<code>v (3f+2f+1)</code>的<code>QC</code>是基于<code>v (3f+2f-1)</code>的<code>QC</code>。这使得共识无法有效运行，失去了<code>liveness</code>。</p>
<p>更严重的是，这是比<code>hidden lock</code>更为棘手的一个问题，因为这个问题是没法通过等待<span class="math inline">\(\Delta\)</span>来解决的。可能，这也是为什么<code>HotStuff</code>论文的<code>Algorithm 2</code>和<code>Algorithm 3</code>需要对消息的<code>viewNumber</code>进行检查的原因。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Consensus/" rel="tag"># Consensus</a>
              <a href="/tags/PBFT/" rel="tag"># PBFT</a>
              <a href="/tags/Distributed-system/" rel="tag"># Distributed_system</a>
              <a href="/tags/Theory/" rel="tag"># Theory</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/15/unification-parallel-block/" rel="prev" title="A Unified Model of Parallel-Block Blockchains">
      <i class="fa fa-chevron-left"></i> A Unified Model of Parallel-Block Blockchains
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/26/comp-pala-streamlet/" rel="next" title="A Comparison between Pala and Streamlet">
      A Comparison between Pala and Streamlet <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#i.%E4%B8%A4%E4%B8%89%E9%98%B6%E6%AE%B5%E5%85%B1%E8%AF%86%E4%B8%AD%E7%9A%84%E9%94%81%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="nav-number">1.</span> <span class="nav-text">I.两&#x2F;三阶段共识中的锁定机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ii.%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E4%B8%ADleader%E5%8F%AF%E4%BF%A1%E5%BA%A6%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">2.</span> <span class="nav-text">II.共识协议中Leader可信度的不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iii.single-modal%E7%B1%BB%E5%85%B1%E8%AF%86%E4%B8%AD%E9%94%81%E5%AE%9A%E6%9C%BA%E5%88%B6%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.</span> <span class="nav-text">III.Single-modal类共识中锁定机制的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a.-%E5%AF%B9%E9%94%81%E5%AE%9A%E6%9C%BA%E5%88%B6%E4%B8%AD%E8%A7%84%E5%88%992%E6%B4%BB%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">3.1.</span> <span class="nav-text">A. 对锁定机制中规则2活性的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b.-%E4%B8%BA%E4%BB%80%E4%B9%88tendermint%E5%9C%A8%E8%BF%9B%E8%A1%8Cleader%E5%88%87%E6%8D%A2%E7%9A%84%E6%97%B6%E5%80%99%E8%A6%81%E7%AD%89%E5%BE%85delta"><span class="nav-number">3.2.</span> <span class="nav-text">B. 为什么Tendermint在进行leader切换的时候要等待\(\Delta\)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tendermint%E4%B8%8D%E7%AD%89%E5%BE%85delta%E5%AF%BC%E8%87%B4%E7%9A%84hidden-lock%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.1.</span> <span class="nav-text">1. Tendermint不等待\(\Delta\)导致的Hidden Lock问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AD%89%E5%BE%85delta%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3hidden-lock%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.2.</span> <span class="nav-text">2. 为什么等待\(\Delta\)可以解决Hidden Lock问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c.-%E4%B8%BA%E4%BB%80%E4%B9%88hotstuff%E4%B8%8D%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85delta"><span class="nav-number">3.3.</span> <span class="nav-text">C. 为什么HotStuff不需要等待\(\Delta\)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iv.-%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98replica%E6%8E%A5%E6%94%B6%E5%88%B0%E6%97%A7view%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">IV. 一个问题：replica接收到旧view中的消息如何处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a.-%E5%81%87%E8%AE%BE%E4%B8%80%E8%AE%A4%E4%B8%BA%E6%97%A7view%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%98%AF%E6%97%A0%E6%95%88%E7%9A%84"><span class="nav-number">4.1.</span> <span class="nav-text">A. 假设一：认为旧view中的消息是无效的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b.-%E5%81%87%E8%AE%BE%E4%BA%8C%E8%AE%A4%E4%B8%BA%E6%97%A7view%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%89%E6%95%88%E7%9A%84"><span class="nav-number">4.2.</span> <span class="nav-text">B. 假设二：认为旧view中的消息有效的</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Seafooler</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:seafooler@gmail.com" title="E-Mail → mailto:seafooler@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Seafooler</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : ,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>












  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
